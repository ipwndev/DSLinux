/****************************************************************************
** Khtmlwidget meta object code from reading C++ file 'html.h'
**
** Created: Thu Jul 6 09:38:02 2000
**      by: The Qt Meta Object Compiler ($Revision$)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#if !defined(Q_MOC_OUTPUT_REVISION)
#define Q_MOC_OUTPUT_REVISION 2
#elif Q_MOC_OUTPUT_REVISION != 2
#error "Moc format conflict - please regenerate all moc files"
#endif

#include <unistd.h>
#include <signal.h>
#include <qmetaobject.h>


const char *KHTMLWidget::className() const
{
    return "KHTMLWidget";
}

QMetaObject *KHTMLWidget::metaObj = 0;


#if QT_VERSION >= 200
static QMetaObjectInit init_KHTMLWidget(&KHTMLWidget::staticMetaObject);

#endif

void KHTMLWidget::initMetaObject()
{
    if ( metaObj )
	return;
    if ( strcmp(KDNDWidget::className(), "KDNDWidget") != 0 )
	badSuperclassWarning("KHTMLWidget","KDNDWidget");

#if QT_VERSION >= 200
    staticMetaObject();
}

void KHTMLWidget::staticMetaObject()
{
    if ( metaObj )
	return;
    KDNDWidget::staticMetaObject();
#else

    KDNDWidget::initMetaObject();
#endif

    typedef void(KHTMLWidget::*m1_t0)(int);
    typedef void(KHTMLWidget::*m1_t1)(int);
    typedef void(KHTMLWidget::*m1_t2)(const char*,const char*);
    typedef void(KHTMLWidget::*m1_t3)();
    typedef void(KHTMLWidget::*m1_t4)();
    typedef void(KHTMLWidget::*m1_t5)();
    typedef void(KHTMLWidget::*m1_t6)(int);
    typedef void(KHTMLWidget::*m1_t7)(const char*,const char*,const char*);
    typedef void(KHTMLWidget::*m1_t8)(KHTMLView*);
    m1_t0 v1_0 = &KHTMLWidget::slotScrollVert;
    m1_t1 v1_1 = &KHTMLWidget::slotScrollHorz;
    m1_t2 v1_2 = &KHTMLWidget::slotFileLoaded;
    m1_t3 v1_3 = &KHTMLWidget::scrollBlobTimeout;
    m1_t4 v1_4 = &KHTMLWidget::slotUpdate;
    m1_t5 v1_5 = &KHTMLWidget::slotAutoScrollY;
    m1_t6 v1_6 = &KHTMLWidget::slotUpdateSelectText;
    m1_t7 v1_7 = &KHTMLWidget::slotFormSubmitted;
    m1_t8 v1_8 = &KHTMLWidget::slotFrameSelected;
    QMetaData *slot_tbl = new QMetaData[9];
    slot_tbl[0].name = "slotScrollVert(int)";
    slot_tbl[1].name = "slotScrollHorz(int)";
    slot_tbl[2].name = "slotFileLoaded(const char*,const char*)";
    slot_tbl[3].name = "scrollBlobTimeout()";
    slot_tbl[4].name = "slotUpdate()";
    slot_tbl[5].name = "slotAutoScrollY()";
    slot_tbl[6].name = "slotUpdateSelectText(int)";
    slot_tbl[7].name = "slotFormSubmitted(const char*,const char*,const char*)";
    slot_tbl[8].name = "slotFrameSelected(KHTMLView*)";
    slot_tbl[0].ptr = *((QMember*)&v1_0);
    slot_tbl[1].ptr = *((QMember*)&v1_1);
    slot_tbl[2].ptr = *((QMember*)&v1_2);
    slot_tbl[3].ptr = *((QMember*)&v1_3);
    slot_tbl[4].ptr = *((QMember*)&v1_4);
    slot_tbl[5].ptr = *((QMember*)&v1_5);
    slot_tbl[6].ptr = *((QMember*)&v1_6);
    slot_tbl[7].ptr = *((QMember*)&v1_7);
    slot_tbl[8].ptr = *((QMember*)&v1_8);
    typedef void(KHTMLWidget::*m2_t0)(const char*);
    typedef void(KHTMLWidget::*m2_t1)();
    typedef void(KHTMLWidget::*m2_t2)();
    typedef void(KHTMLWidget::*m2_t3)();
    typedef void(KHTMLWidget::*m2_t4)(const char*,int);
    typedef void(KHTMLWidget::*m2_t5)(int);
    typedef void(KHTMLWidget::*m2_t6)(int);
    typedef void(KHTMLWidget::*m2_t7)(const char*,int);
    typedef void(KHTMLWidget::*m2_t8)(const char*,int,const char*);
    typedef void(KHTMLWidget::*m2_t9)(const char*);
    typedef void(KHTMLWidget::*m2_t10)(bool);
    typedef void(KHTMLWidget::*m2_t11)();
    typedef void(KHTMLWidget::*m2_t12)();
    typedef void(KHTMLWidget::*m2_t13)();
    typedef void(KHTMLWidget::*m2_t14)(const char*,const QPoint&);
    typedef void(KHTMLWidget::*m2_t15)(const char*,const char*,QMouseEvent*);
    typedef void(KHTMLWidget::*m2_t16)(const char*);
    typedef void(KHTMLWidget::*m2_t17)(const char*);
    typedef void(KHTMLWidget::*m2_t18)(const char*,const char*,const char*);
    typedef void(KHTMLWidget::*m2_t19)(const QSize&);
    typedef void(KHTMLWidget::*m2_t20)(int,const char*);
#ifdef EXEC_EXTENSIONS
    typedef void(KHTMLWidget::*m2_t21)(const char *);
#endif
    m2_t0 v2_0 = &KHTMLWidget::setTitle;
    m2_t1 v2_1 = &KHTMLWidget::goUp;
    m2_t2 v2_2 = &KHTMLWidget::goLeft;
    m2_t3 v2_3 = &KHTMLWidget::goRight;
    m2_t4 v2_4 = &KHTMLWidget::doubleClick;
    m2_t5 v2_5 = &KHTMLWidget::scrollVert;
    m2_t6 v2_6 = &KHTMLWidget::scrollHorz;
    m2_t7 v2_7 = &KHTMLWidget::URLSelected;
    m2_t8 v2_8 = &KHTMLWidget::URLSelected;
    m2_t9 v2_9 = &KHTMLWidget::onURL;
    m2_t10 v2_10 = &KHTMLWidget::textSelected;
    m2_t11 v2_11 = &KHTMLWidget::documentChanged;
    m2_t12 v2_12 = &KHTMLWidget::documentStarted;
    m2_t13 v2_13 = &KHTMLWidget::documentDone;
    m2_t14 v2_14 = &KHTMLWidget::popupMenu;
    m2_t15 v2_15 = &KHTMLWidget::mousePressed;
    m2_t16 v2_16 = &KHTMLWidget::fileRequest;
    m2_t17 v2_17 = &KHTMLWidget::cancelFileRequest;
    m2_t18 v2_18 = &KHTMLWidget::formSubmitted;
    m2_t19 v2_19 = &KHTMLWidget::resized;
    m2_t20 v2_20 = &KHTMLWidget::redirect;
#ifdef EXEC_EXTENSIONS
    m2_t21 v2_21 = &KHTMLWidget::execfunc;
    QMetaData *signal_tbl = new QMetaData[22];
#else
    QMetaData *signal_tbl = new QMetaData[21];
#endif
    signal_tbl[0].name = "setTitle(const char*)";
    signal_tbl[1].name = "goUp()";
    signal_tbl[2].name = "goLeft()";
    signal_tbl[3].name = "goRight()";
    signal_tbl[4].name = "doubleClick(const char*,int)";
    signal_tbl[5].name = "scrollVert(int)";
    signal_tbl[6].name = "scrollHorz(int)";
    signal_tbl[7].name = "URLSelected(const char*,int)";
    signal_tbl[8].name = "URLSelected(const char*,int,const char*)";
    signal_tbl[9].name = "onURL(const char*)";
    signal_tbl[10].name = "textSelected(bool)";
    signal_tbl[11].name = "documentChanged()";
    signal_tbl[12].name = "documentStarted()";
    signal_tbl[13].name = "documentDone()";
    signal_tbl[14].name = "popupMenu(const char*,const QPoint&)";
    signal_tbl[15].name = "mousePressed(const char*,const char*,QMouseEvent*)";
    signal_tbl[16].name = "fileRequest(const char*)";
    signal_tbl[17].name = "cancelFileRequest(const char*)";
    signal_tbl[18].name = "formSubmitted(const char*,const char*,const char*)";
    signal_tbl[19].name = "resized(const QSize&)";
    signal_tbl[20].name = "redirect(int,const char*)";
#ifdef EXEC_EXTENSIONS
    signal_tbl[21].name = "execfunc(const char *)";
#endif
    signal_tbl[0].ptr = *((QMember*)&v2_0);
    signal_tbl[1].ptr = *((QMember*)&v2_1);
    signal_tbl[2].ptr = *((QMember*)&v2_2);
    signal_tbl[3].ptr = *((QMember*)&v2_3);
    signal_tbl[4].ptr = *((QMember*)&v2_4);
    signal_tbl[5].ptr = *((QMember*)&v2_5);
    signal_tbl[6].ptr = *((QMember*)&v2_6);
    signal_tbl[7].ptr = *((QMember*)&v2_7);
    signal_tbl[8].ptr = *((QMember*)&v2_8);
    signal_tbl[9].ptr = *((QMember*)&v2_9);
    signal_tbl[10].ptr = *((QMember*)&v2_10);
    signal_tbl[11].ptr = *((QMember*)&v2_11);
    signal_tbl[12].ptr = *((QMember*)&v2_12);
    signal_tbl[13].ptr = *((QMember*)&v2_13);
    signal_tbl[14].ptr = *((QMember*)&v2_14);
    signal_tbl[15].ptr = *((QMember*)&v2_15);
    signal_tbl[16].ptr = *((QMember*)&v2_16);
    signal_tbl[17].ptr = *((QMember*)&v2_17);
    signal_tbl[18].ptr = *((QMember*)&v2_18);
    signal_tbl[19].ptr = *((QMember*)&v2_19);
    signal_tbl[20].ptr = *((QMember*)&v2_20);
#ifdef EXEC_EXTENSIONS
    signal_tbl[21].ptr = *((QMember*)&v2_21);
    metaObj = new QMetaObject("KHTMLWidget","KDNDWidget",slot_tbl,9,signal_tbl,22);
#else
    metaObj = new QMetaObject("KHTMLWidget","KDNDWidget",slot_tbl,9,signal_tbl,21);
#endif
}

// SIGNAL setTitle
void KHTMLWidget::setTitle( const char* t0 )
{
    activate_signal( "setTitle(const char*)", t0 );
}

// SIGNAL goUp
void KHTMLWidget::goUp()
{
    activate_signal( "goUp()" );
}

// SIGNAL goLeft
void KHTMLWidget::goLeft()
{
    activate_signal( "goLeft()" );
}

// SIGNAL goRight
void KHTMLWidget::goRight()
{
    activate_signal( "goRight()" );
}

#include <qobjectdefs.h>
#if QT_VERSION >= 141
// newer implementation
#include <qsignalslotimp.h>
#else
// for late-model 1.x header files
#if !defined(Q_MOC_CONNECTIONLIST_DECLARED)
#define Q_MOC_CONNECTIONLIST_DECLARED
#include <qlist.h>
Q_DECLARE(QListM,QConnection);
Q_DECLARE(QListIteratorM,QConnection);
#endif
#endif

// SIGNAL doubleClick
void KHTMLWidget::doubleClick( const char* t0, int t1 )
{
    QConnectionList *clist = receivers("doubleClick(const char*,int)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(const char*);
    typedef RT1 *PRT1;
    typedef void (QObject::*RT2)(const char*,int);
    typedef RT2 *PRT2;
    RT0 r0;
    RT1 r1;
    RT2 r2;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	    case 2:
		r2 = *((PRT2)(c->member()));
		(object->*r2)(t0, t1);
		break;
	}
    }
}

// SIGNAL scrollVert
void KHTMLWidget::scrollVert( int t0 )
{
    activate_signal( "scrollVert(int)", t0 );
}

// SIGNAL scrollHorz
void KHTMLWidget::scrollHorz( int t0 )
{
    activate_signal( "scrollHorz(int)", t0 );
}

// SIGNAL URLSelected
void KHTMLWidget::URLSelected( const char* t0, int t1 )
{
    QConnectionList *clist = receivers("URLSelected(const char*,int)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(const char*);
    typedef RT1 *PRT1;
    typedef void (QObject::*RT2)(const char*,int);
    typedef RT2 *PRT2;
    RT0 r0;
    RT1 r1;
    RT2 r2;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	    case 2:
		r2 = *((PRT2)(c->member()));
		(object->*r2)(t0, t1);
		break;
	}
    }
}

// SIGNAL URLSelected
void KHTMLWidget::URLSelected( const char* t0, int t1, const char* t2 )
{
    QConnectionList *clist = receivers("URLSelected(const char*,int,const char*)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(const char*);
    typedef RT1 *PRT1;
    typedef void (QObject::*RT2)(const char*,int);
    typedef RT2 *PRT2;
    typedef void (QObject::*RT3)(const char*,int,const char*);
    typedef RT3 *PRT3;
    RT0 r0;
    RT1 r1;
    RT2 r2;
    RT3 r3;

    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
	
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	    case 2:
		r2 = *((PRT2)(c->member()));
		(object->*r2)(t0, t1);
		break;
	    case 3:
		r3 = *((PRT3)(c->member()));
		(object->*r3)(t0, t1, t2);
		break;
	}
    }
}

// SIGNAL onURL
void KHTMLWidget::onURL( const char* t0 )
{
    activate_signal( "onURL(const char*)", t0 );
}

// SIGNAL textSelected
void KHTMLWidget::textSelected( bool t0 )
{
    QConnectionList *clist = receivers("textSelected(bool)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(bool);
    typedef RT1 *PRT1;
    RT0 r0;
    RT1 r1;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	}
    }
}

// SIGNAL documentChanged
void KHTMLWidget::documentChanged()
{
    activate_signal( "documentChanged()" );
}

// SIGNAL documentStarted
void KHTMLWidget::documentStarted()
{
    activate_signal( "documentStarted()" );
}

// SIGNAL documentDone
void KHTMLWidget::documentDone()
{
//	cerr << "html.moc: signalling document done!\n";
    activate_signal( "documentDone()" );
}

// SIGNAL popupMenu
void KHTMLWidget::popupMenu( const char* t0, const QPoint& t1 )
{
    QConnectionList *clist = receivers("popupMenu(const char*,const QPoint&)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(const char*);
    typedef RT1 *PRT1;
    typedef void (QObject::*RT2)(const char*,const QPoint&);
    typedef RT2 *PRT2;
    RT0 r0;
    RT1 r1;
    RT2 r2;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	    case 2:
		r2 = *((PRT2)(c->member()));
		(object->*r2)(t0, t1);
		break;
	}
    }
}

// SIGNAL mousePressed
void KHTMLWidget::mousePressed( const char* t0, const char* t1, QMouseEvent* t2 )
{
    QConnectionList *clist = receivers("mousePressed(const char*,const char*,QMouseEvent*)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(const char*);
    typedef RT1 *PRT1;
    typedef void (QObject::*RT2)(const char*,const char*);
    typedef RT2 *PRT2;
    typedef void (QObject::*RT3)(const char*,const char*,QMouseEvent*);
    typedef RT3 *PRT3;
    RT0 r0;
    RT1 r1;
    RT2 r2;
    RT3 r3;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	    case 2:
		r2 = *((PRT2)(c->member()));
		(object->*r2)(t0, t1);
		break;
	    case 3:
		r3 = *((PRT3)(c->member()));
		(object->*r3)(t0, t1, t2);
		break;
	}
    }
}

// SIGNAL fileRequest
void KHTMLWidget::fileRequest( const char* t0 )
{
    activate_signal( "fileRequest(const char*)", t0 );
}

// SIGNAL cancelFileRequest
void KHTMLWidget::cancelFileRequest( const char* t0 )
{
    activate_signal( "cancelFileRequest(const char*)", t0 );
}

// SIGNAL formSubmitted
void KHTMLWidget::formSubmitted( const char* t0, const char* t1, const char* t2 )
{
    QConnectionList *clist = receivers("formSubmitted(const char*,const char*,const char*)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(const char*);
    typedef RT1 *PRT1;
    typedef void (QObject::*RT2)(const char*,const char*);
    typedef RT2 *PRT2;
    typedef void (QObject::*RT3)(const char*,const char*,const char*);
    typedef RT3 *PRT3;
    RT0 r0;
    RT1 r1;
    RT2 r2;
    RT3 r3;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	    case 2:
		r2 = *((PRT2)(c->member()));
		(object->*r2)(t0, t1);
		break;
	    case 3:
		r3 = *((PRT3)(c->member()));
		(object->*r3)(t0, t1, t2);
		break;
	}
    }
}

// SIGNAL resized
void KHTMLWidget::resized( const QSize& t0 )
{
    QConnectionList *clist = receivers("resized(const QSize&)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(const QSize&);
    typedef RT1 *PRT1;
    RT0 r0;
    RT1 r1;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	}
    }
}

// SIGNAL redirect
void KHTMLWidget::redirect( int t0, const char* t1 )
{
    QConnectionList *clist = receivers("redirect(int,const char*)");
    if ( !clist || signalsBlocked() )
	return;
    typedef void (QObject::*RT0)();
    typedef RT0 *PRT0;
    typedef void (QObject::*RT1)(int);
    typedef RT1 *PRT1;
    typedef void (QObject::*RT2)(int,const char*);
    typedef RT2 *PRT2;
    RT0 r0;
    RT1 r1;
    RT2 r2;
    QConnectionListIt it(*clist);
    QConnection   *c;
    QSenderObject *object;
    while ( (c=it.current()) ) {
	++it;
	object = (QSenderObject*)c->object();
	object->setSender( this );
	switch ( c->numArgs() ) {
	    case 0:
		r0 = *((PRT0)(c->member()));
		(object->*r0)();
		break;
	    case 1:
		r1 = *((PRT1)(c->member()));
		(object->*r1)(t0);
		break;
	    case 2:
		r2 = *((PRT2)(c->member()));
		(object->*r2)(t0, t1);
		break;
	}
    }
}



#ifdef EXEC_EXTENSIONS
#define MAX_PARMS 16
#define MAX_PARM_LEN 256
static int sigflag = 0;
// SIGNAL execfunc
void KHTMLWidget::execfunc(const char *cmd)
{
  char parms[MAX_PARMS * (MAX_PARM_LEN + 1)];
  char buf[256],chr,*plist[MAX_PARMS],*str;
  int count,index,pid;
  struct sigaction schild,soldchild;

  // only exec programs from local HTML pages
  KURL kurl = getDocumentURL();
  strcpy(buf,kurl.url());
  if(strncmp(buf,"file:",5) != 0)
    return;

  // initialize the parmlist
  count = 0;
  do
  {
    plist[count] = parms + (count * (MAX_PARM_LEN + 1));
    *plist[count] = 0x00;
  }while(++count < MAX_PARMS);

  // extract the executable and parms from the command string
  count = index = 0;
  while(1)
  {
    // get next char and check for end of parms
    chr = *cmd++;
    if(chr == 0x00)
    {
      *(plist[index] + count) = 0x00;
      break;
    }

    // check for delimeter
    if(chr == ',')
    {
      *(plist[index++] + count) = 0x00;
      count = 0;
      continue;
    }

    // add chr to current string
    *(plist[index] + count++) = chr;
  }

  // null empty pointers
  count = 0;
  do
  {
    if(*plist[count] == 0x00)
      plist[count] = NULL;
  }while(++count < MAX_PARMS);
  
#ifdef NEVER
  printf("*** About to spawn the following executable in the MOC:\n");
  printf("Executable: \"%s\"\n",plist[0]);
  count = 1;
  do
  {
    if(plist[count] != NULL)
      printf("Parm%02d:     \"%s\"\n",count,plist[count]);
  }while(++count < MAX_PARMS);
#endif

  // install the signal handler to avoid zombie processes
  if(sigflag == 0)
  {
    sigflag = 1;
    memset(&schild,0,sizeof(schild));
    schild.sa_handler = SIG_IGN;
    sigaction(SIGCHLD,&schild,&soldchild);    
  }

  // spawn the new process
  pid = vfork();
  if(pid != 0)
  {
    return;
  }

  // this code is only executed in the child process
  execvp(plist[0],plist);
  exit(0);
}
#endif

