/*                                                                       
 * Copyright (c) 2003 Century Software, Inc.   All Rights Reserved.     
 *                                                                       
 * This file is part of the PIXIL Operating Environment                 
 *                                                                       
 * The use, copying and distribution of this file is governed by one    
 * of two licenses, the PIXIL Commercial License, or the GNU General    
 * Public License, version 2.                                           
 *                                                                       
 * Licensees holding a valid PIXIL Commercial License may use this file 
 * in accordance with the PIXIL Commercial License Agreement provided   
 * with the Software. Others are governed under the terms of the GNU   
 * General Public License version 2.                                    
 *                                                                       
 * This file may be distributed and/or modified under the terms of the  
 * GNU General Public License version 2 as published by the Free        
 * Software Foundation and appearing in the file LICENSE.GPL included   
 * in the packaging of this file.                                      
 *                                                                       
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING  
 * THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A            
 * PARTICULAR PURPOSE.                                                  
 *                                                                       
 * RESTRICTED RIGHTS LEGEND                                             
 *                                                                     
 * Use, duplication, or disclosure by the government is subject to      
 * restriction as set forth in paragraph (b)(3)(b) of the Rights in     
 * Technical Data and Computer Software clause in DAR 7-104.9(a).       
 *                                                                      
 * See http://www.pixil.org/gpl/ for GPL licensing       
 * information.                                                         
 *                                                                      
 * See http://www.pixil.org/license.html or              
 * email cetsales@centurysoftware.com for information about the PIXIL   
 * Commercial License Agreement, or if any conditions of this licensing 
 * are not clear to you.                                                
 */


/*
**
** Imported "Include" Files
**
*/
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "bmptools.h"



/*
**
** Local Constant Definitions
**
*/
#define HEADERSTR1 "************************************************************************\n"
#define HEADERSTR2 "* nxkeyboard map file automatically generated by 'buildmap'            *\n"
#define HEADERSTR3 "*                                                                      *\n"



/*
**
** Local Enumeration Definitions
**
*/



/*
**
** Local Structure Definitions
**
*/
typedef struct
{
    int x;
    int y;
}
Point;

typedef struct
{
    Point upperleft;
    Point lowerright;
}
Rect;



/*
**
** Local Variable Declarations
**
*/
char *(header[]) =
{
NULL};



/*
**
** The following function will recover the pixel value for the specified
** x,y position.
**
** If the pixel is black, '0' is returned. If the pixel is white, '1' is
** returned. If an error occurs, a negative value is returned.
**
*/
static int
getPixel(BmpHandle * handle, int xpos, int ypos)
{
    BmpColor color;
    int result;

    // recover the pixel
    result = bmpGetPixel(handle, xpos, ypos, &color);
    if (result)
	return (-1);

    // printf("%d,%d: %d,%d,%d\n",xpos,ypos,color.red,color.green,color.blue);

    // check for black pixel
    if ((color.red == 255) && (color.green == 255) && (color.blue == 255))
	return (1);

    // chcek for black pixel
    if ((color.red == 0) && (color.green == 0) && (color.blue == 0))
	return (0);

    // unknown pixel
    return (-2);
}



/*
**
** The following function will parse the entire image, looking for the next
** white pixel. The function will parse all scan lines in the image.
**
** If successful, '0' is returned and the pixel position is saved at "result".
** If the end of the image is found, '1' is returned. If an error occurs, a
** negative value is returned.
**
*/
static int
findWhitePixel(BmpHandle * handle, int xpos, int ypos, Point * result)
{
    int res;

    // locate the next black pixel
    while (1) {
	res = getPixel(handle, xpos, ypos);
	if (res < 0)
	    return (res);
	if (res == 0)
	    break;
	if (++xpos >= handle->info.width) {
	    xpos = 0;
	    if (++ypos >= handle->info.height)
		return (1);
	}
    }

    // locate the next white pixel
    while (1) {
	res = getPixel(handle, xpos, ypos);
	if (res < 0)
	    return (res);
	if (res == 1)
	    break;
	if (++xpos >= handle->info.width) {
	    xpos = 0;
	    if (++ypos >= handle->info.height)
		return (1);
	}
    }

    // save result
    result->x = xpos;
    result->y = ypos;

    // exit with no errors
    return (0);
}



/*
**
** The following function will parse the image, looking for the next white
** pixel on this row. The function will only parse the width of the image.
**
** If successful, '0' is returned and the pixel position is saved at "result".
** If the end of the row is found, '1' is returned. If an error occurs, a
** negative value is returned.
**
*/
static int
findNextWhitePixel(BmpHandle * handle, int xpos, int ypos, Point * result)
{
    int res;

    // find the next black pixel
    while (1) {
	res = getPixel(handle, xpos, ypos);
	if (res < 0)
	    return (res);
	if (res == 0)
	    break;
	if (++xpos >= handle->info.width)
	    return (1);
    }

    // find the next white pixel
    while (1) {
	res = getPixel(handle, xpos, ypos);
	if (res < 0)
	    return (res);
	if (res == 1)
	    break;
	if (++xpos >= handle->info.width)
	    return (1);
    }

    // save result
    result->x = xpos;
    result->y = ypos;

    // exit with no errors
    return (0);
}



/*
**
** The following function will recover a rectangle that specifies the area
** covered by a key.
**
** If successful, '0' is returned and the key area is stored at "result".
** If an error occurrs, a negative value is returned.
**
*/
static int
findCorners(BmpHandle * handle, int xpos, int ypos, Rect * result)
{
    int res;

    // make sure the pixel is white
    res = getPixel(handle, xpos, ypos);
    if (res < 0)
	return (res);
    if (res != 1)
	return (-100);

    // make sure the pixel is on a left edge
    while (1) {
	res = getPixel(handle, xpos - 1, ypos);
	if (res < 0)
	    return (res);
	if (res == 0)
	    break;
	--xpos;
    }

    // make sure the pixel is on a top edge
    while (1) {
	res = getPixel(handle, xpos, ypos - 1);
	if (res < 0)
	    return (res);
	if (res == 0)
	    break;
	--ypos;
    }

    // save the top and left edges
    result->upperleft.x = xpos;
    result->upperleft.y = ypos;

    // find the right edge
    while (1) {
	res = getPixel(handle, xpos + 1, ypos);
	if (res < 0)
	    return (res);
	if (res == 0)
	    break;
	++xpos;
    }

    // find the bottom edge
    while (1) {
	res = getPixel(handle, xpos, ypos + 1);
	if (res < 0)
	    return (res);
	if (res == 0)
	    break;
	++ypos;
    }

    // save the right and bottom edges
    result->lowerright.x = xpos;
    result->lowerright.y = ypos;

    // exit with no errors
    return (0);
}



/*
**
**
**
*/
static int
stripExtension(char *str, char *result)
{
    int index;

    // create a copy of the string
    strcpy(result, str);

    // remove the extension
    index = strlen(result) - 1;
    while (index >= 0) {
	if (*(result + index) == '.')
	    break;
	--index;
    }

    // modify result
    if (index < 0)
	*result = 0x00;
    else
	*(result + index + 1) = 0x00;

    // exit with no errors
    return (0);
}



/*
**
**
**
*/
int
main(int argc, char *argv[])
{
    FILE *fp;
    BmpColor pixel;
    BmpHandle *handle;
    Point point;
    Rect rect;
    char buf1[1024], buf2[1024];
    int count, keycnt, result, rowcnt, tkeys, trows, xref, yref;
    time_t tval;

    // open and load the BMP image
    handle = bmpLoadImage(argv[1]);
    if (handle == NULL) {
	printf("Unable to open \"%s\"...\n", argv[1]);
	return (-1);
    }
    // display image information
    printf("\nProcessing %s:\n", argv[1]);
    if (handle->info.bits_per_pixel == 1)
	printf("   %d x %d monochrome image\n",
	       handle->info.width, handle->info.height);
    else if (handle->info.bits_per_pixel == 4)
	printf("   %d x %d 16 color image\n",
	       handle->info.width, handle->info.height);
    else if (handle->info.bits_per_pixel == 8)
	printf("   %d x %d 256 color image\n",
	       handle->info.width, handle->info.height);
    else if (handle->info.bits_per_pixel == 16)
	printf("   %d x %d 65536 color image\n",
	       handle->info.width, handle->info.height);
    else if (handle->info.bits_per_pixel == 24)
	printf("   %d x %d 16777216 color image\n",
	       handle->info.width, handle->info.height);

    // display the palette information
    count = 0;
    while (1) {
	if (bmpGetPaletteEntry(handle, count, &pixel) != 0)
	    break;
	printf("   Palette%d: R:%3d G:%3d B:%3d\n",
	       count++, pixel.red, pixel.green, pixel.blue);
    }

    // create the map file
    stripExtension(argv[1], buf1);
    strcat(buf1, "map");
    if ((fp = fopen(buf1, "w")) == NULL) {
	printf("Unable to open \"%s\"\n", buf1);
	bmpCloseImage(handle);
	return (-2);
    }
    // write out the map file header
    fprintf(fp, HEADERSTR1);
    fprintf(fp, HEADERSTR2);

    strcpy(buf2, HEADERSTR3);
    strncpy(buf2 + 2, "Image File:", 11);
    strcpy(buf1, argv[1]);
    count = 0;
    while (buf1[count])
	buf2[count + 14] = buf1[count++];
    fprintf(fp, buf2);

    strcpy(buf2, HEADERSTR3);
    strncpy(buf2 + 2, "Date:", 5);
    tval = time(NULL);
    strcpy(buf1, ctime(&tval));
    buf1[strlen(buf1) - 1] = 0x00;
    count = 0;
    while (buf1[count])
	buf2[count + 14] = buf1[count++];
    fprintf(fp, buf2);

    fprintf(fp, HEADERSTR1);
    fprintf(fp, "\n");

    // write out the map file parameters
    fprintf(fp, "******************\n");
    fprintf(fp, "* Map Parameters *\n");
    fprintf(fp, "******************\n");
    fprintf(fp,
	    "parms: #,#,#,#,#,%d,%d   |ID,high1,high2,high3,high4,width,height\n",
	    handle->info.width, handle->info.height);

    // process all key areas found in the bitmap
    keycnt = rowcnt = 1;
    trows = tkeys = 0;
    xref = yref = 0;
    while (1) {
	result = findWhitePixel(handle, xref, yref, &point);
	if (result == 1)
	    break;
	if (result) {
	    printf
		("Unable to find a white pixel using %d,%d as a reference\n",
		 xref, yref);
	    fclose(fp);
	    bmpCloseImage(handle);
	    return (-2);
	}
	++trows;

	fprintf(fp, "\n");
	fprintf(fp, "******************\n");
	fprintf(fp, "* Row %2d Keymaps *\n", rowcnt);
	fprintf(fp, "******************\n");

	while (1) {
	    result = findCorners(handle, point.x, point.y, &rect);
	    if (result) {
		printf("Unable to find corners using %d,%d as a reference.\n",
		       point.x, point.y);
		fclose(fp);
		bmpCloseImage(handle);
		return (-3);
	    }
	    ++tkeys;

	    fprintf(fp, "keymap: #,%d,%d,%d,%d   |Row%dKey%d\n",
		    rect.upperleft.x,
		    rect.upperleft.y,
		    rect.lowerright.x, rect.lowerright.y, rowcnt, keycnt++);
	    fflush(fp);

	    result = findNextWhitePixel(handle, point.x, point.y, &point);
	    if (result < 0) {
		printf
		    ("Unable to find next white pixel using %d,%d as a reference\n.",
		     point.x, point.y);
		fclose(fp);
		bmpCloseImage(handle);
		return (-4);
	    }
	    if (result == 1) {
		keycnt = 1;
		++rowcnt;
		xref = 0;
		yref = rect.lowerright.y + 1;
		break;
	    }
	}
    }

    // add multikey header
    fprintf(fp, "\n***********************\n");
    fprintf(fp, "* Multikey Extensions *\n");
    fprintf(fp, "***********************\n");

    // display final totals
    printf("   Located %d keyrows, generated %d keymaps\n", trows, tkeys);
    printf("   Complete!\n\n");

    // do housekeeping
    fclose(fp);
    bmpCloseImage(handle);

    // exit with no errors
    return (0);
}
