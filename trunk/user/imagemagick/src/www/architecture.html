<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<head>
  <style type="text/css" media="screen,projection"><!--
    @import url("../www/magick.css");
  //--></style>
  <meta name="verify-v1" content="g222frIIxcQTrvDR3NBRUSKP3AnMNoqxOkIniCEkV7U=" />
  <link rel="meta" type="application/rdf+xml" title="ICI" href="http://imagemagick.org/ici.rdf" />
  <title>ImageMagick: Architecture</title>
  <meta http-equiv="Content-Language" content="en-US"/>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta http-equiv="Reply-to" content="magick-users@imagemagick.org"/>
  <meta name="Generator" content="PHP"/>
  <meta name="Keywords" content="architecture, ImageMagick, ImageMagic, MagickCore, MagickWand, PerlMagick, Magick++, RMagick, PythonMagick, JMagick, TclMagick, Image, Magick, Magic, Wand, ImageMagickObject"/>
  <meta name="Description" content="ImageMagick® is a software suite to create, edit, and compose bitmap images. It can read, convert and write images in a variety of formats (about 100) including GIF, JPEG, JPEG-2000, PNG, PDF, PhotoCD, TIFF, and DPX. Use ImageMagick to translate, flip, mirror, rotate, scale, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.  ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you can freely use, copy, modify, and distribute. Its license is compatible with the GPL. It runs on all major operating systems.  The functionality of ImageMagick is typically utilized from the command line or you can use the features from programs written in your favorite programming language. Choose from these interfaces: MagickCore (C), MagickWand (C), ChMagick (Ch), Magick++ (C++), JMagick (Java), L-Magick (Lisp), PascalMagick (Pascal), PerlMagick (Perl), MagickWand for PHP (PHP), PythonMagick (Python), RMagick (Ruby), or TclMagick (Tcl/TK). With a language interface, use ImageMagick to modify or create images automagically and dynamically."/>
  <meta name="Rating" content="GENERAL"/>
  <meta name="Robots" content="INDEX, FOLLOW"/>
  <meta name="Generator" content="ImageMagick Studio LLC"/>
  <meta name="Author" content="ImageMagick Studio LLC"/>
  <meta name="Revisit-after" content="2 DAYS"/>
  <meta name="Resource-type" content="document"/>
  <meta name="Copyright" content="Copyright (c) 1999-2008 ImageMagick Studio LLC"/>
  <meta name="Distribution" content="Global"/>
  <link rel="shortcut icon" href="../images/wand.ico"  type="images/vnd.microsoft.icon"/>
</head>

<body id="www-imagemagick-org">
  <table id="titlebar" style="width: 100%;background-color: #f5f5f5" cellpadding="0" cellspacing="0" border="0" summary="ImageMagick">
    <tbody>
      <tr valign="top">
        <td align="left"><a href="../index.html"><img id="titlebar-west" src="../images/script.png" alt="[ImageMagick]" width="350" height="60" vspace="28" name="titlebar-west"/></a></td>
        <td align="left"><a href="https://secure.networkredux.com/affiliate/idevaffiliate.html?id=146" target="1757915363"><img id="titlebar-west" src="../images/networkredux.png" alt="[sponsor]" border="0" vspace="45" name="titlebar-west"/></a></td>
        <td width="99%"><br /> </td>
        <td style="background-color: white" align="right"><a href="../index.html"><img src="../images/sprite.jpg" alt="" width="114" height="118" border="0" name="titlebar-east"/></a></td>
        <td style="background-color: white" align="right"><a href="http://www.imagemagick.org/discourse-server/" target="1196194412"><img id="titlebar-east" src="../images/logo.jpg" alt="" width="114" height="118" border="0" name="titlebar-east"/></a></td>
      </tr>
    </tbody>
  </table>

  <table style="width: 100%" border="0" cellpadding="0" cellspacing="0" summary="">
  <tbody>

    <tr valign="top" style="height: 100%;">
      <td id="menu" width="1%" height="100%">
      <p><a href="#main">Skip to page contents</a></p>
      <font size="-1">
      <span>[</span>
      <a href="../index.html">About ImageMagick</a>
  <span>]</span><br /><span>[</span>
      <a href="../www/command-line-tools.html">Command-line Tools</a>
      <a href="../www/command-line-processing.html" class="sub">Processing</a>
      <a href="../www/command-line-options.html" class="sub">Options</a>
      <a href="http://www.imagemagick.org/Usage/" target="1680907647" class="sub">Usage</a>
      <a href="../www/api.html">Program Interfaces</a>
      <a href="../www/magick-wand.html" class="sub">MagickWand</a>
      <a href="../www/magick-core.html" class="sub">MagickCore</a>
      <a href="../www/perl-magick.html" class="sub">PerlMagick</a>
      <a href="../www/Magick++/" target="1109853431" class="sub">Magick++</a>
      <a href="../www/architecture.html">Architecture</a>
  <span>]</span><br /><span>[</span>
      <a href="../www/install-source.html">Install from Source</a>
      <a href="../www/install-source.html#unix" class="sub">Unix</a>
      <a href="../www/install-source.html#windows" class="sub">Windows</a>
      <a href="../www/binary-releases.html">Binary Releases</a>
      <a href="../www/binary-releases.html#unix" class="sub">Unix</a>
      <a href="../www/binary-releases.html#macosx" class="sub">Mac OS X</a>
      <a href="../www/binary-releases.html#windows" class="sub">Windows</a>
      <a href="../www/resources.html">Resources</a>
  <span>]</span><br /><span>[</span>
      <a href="../www/download.html">Download</a>
  <span>]</span><br /><span>[</span>
      <a href="../www/sitemap.html">Site Map</a>
			<a href="../www/links.html" class="sub">Links</a>
  <span>]</span><br /><span>[</span>
      <a href="../www/sponsors.html">Sponsors:</a>
      <fieldset>
  <a href="http://www.nationalrelocation.com/real-estate/" class="sponsor" target="sponsor">Real Estate</a><!-- 200902010250 -->
      <br />
      <a href="http://www.brothersoft.com" class="sponsor" target="sponsor">Software Download</a><!-- 200809010200 -->
      <br />
      <a href="http://www.iceposter.com" class="sponsor" target="sponsor">Posters</a><!-- 200812010200 -->
      <br />
      <a href="http://www.hotel-erb.de"><img src="../images/bw_erb.gif" alt="[Munich Hotel]" width="110" height="40" border="0" name="Munich Hotel"/></a> <!-- 200809010160 -->
      <br />
      <a href="http://www.kmvu.org"><img src="../images/button_kmvu.jpg" alt="[Visually United]" width="110" height="40" border="0" name="kmvu"/></a> <!-- 200808010160 -->
      <br />
      <a href="http://www.ivedc.org"><img src="../images/ivedc.png" alt="[Interactive Video Entertainment Development Centre]" width="105" height="60" border="0" name="ivedc"/></a> <!-- 200808030160 -->
      <br />
      <a href="http://www.imade-art.de"><img src="../images/imade_art2.jpg" alt="[Kunst bei imade-art]" width="116" height="28" border="0" name="Kunst bei imade-art"/></a> <!-- 200811010160 -->
      <br />
      <a href="http://business-directory.com"><img src="../images/business+directory.gif" alt="[Business + Directory]" width="105" height="60" border="0" name="business+directory"/></a> <!-- 200808010160 -->
      </fieldset>
      <span>]</span>
      </font>
      </td>

      <td id="main" valign="top">
<p class="navigation-index">[<a href="#overview">Architecture Overview</a> &bull; <a href="#cache">The Pixel Cache</a> &bull; <a href="#stream">Streaming Pixels</a> &bull; <a href="#properties">Image Properties and Profiles</a> &bull; <a href="#coders">Image Coders</a> &bull; <a href="#filters">Custom Image Filters</a> &bull; <a href="#threads">Threads of Execution</a>]</p>

<p>The citizens of Oz were quite content with their benefactor, the all-powerful Wizard.  They accepted his wisdom and benevolence without ever questioning the who, why, and where of his power.  Like the citizens of Oz, if you feel comfortable that ImageMagick can help you convert, edit, or compose your images without knowing what goes on behind the curtain, feel free to skip this section.  However, if you want to know more about the software and algorithms behind ImageMagick, read on.  To fully benefit from this discussion, you should be comfortable with image nomenclature and be familiar with computer programming.</p>

<div style="margin: auto;">
  <h2><a name="overview"></a>Architecture Overview</h2>
</div>

<p>An image typically consists of a rectangular region of pixels and metadata.  To convert, edit, or compose an image in an efficient manner we need convenient access to any pixel anywhere within the region (and sometimes outside the region).  And in the case of an image sequence, we need access to any pixel of any region of any image in the sequence.  However, there are hundreds of image formats such JPEG, TIFF, PNG, GIF, etc., that makes it difficult to access pixels on demand.  Within these formats we find differences in:</p>

<ul>
  <li>colorspace (e.g RGB, CMYK, YUV, Lab, etc.)</li>
  <li>bit depth (.e.g 1, 4, 8, 12, 16, etc.)</li>
  <li>storage format (e.g. unsigned, signed, float, double, etc.)</li>
  <li>compression (e.g. uncompressed, RLE, Zip, BZip, etc.)</li>
  <li>orientation (i.e. top-to-bottom, right-to-left, etc.),</li>
  <li>layout (.e.g. raw, interspersed with opcodes, etc.)</li>
</ul>

<p>In addition, some image pixels may require attenuation, some formats permit more than one frame, and some formats contain vector graphics that must first be rasterized (converted from vector to pixels).</p>

<p>An efficient implementation of an image processing algorithm may require we get or put:</p>

<ul>
  <li>one pixel a time (e.g. pixel at location 10,3)</li>
  <li>a single scanline (e.g. all pixels from row 4)</li>
  <li>a few scanlines at once (e.g. pixel rows 4-7)</li>
  <li>an arbitrary region of pixels from the image (e.g. pixels defined at 10,7 to 10,19)</li>
  <li>a pixel in random order (e.g. pixel at 14,15 and 640,480)</li>
  <li>pixels from two different images (e.g. pixel at 5,1 from image 1 and pixel at 5,1 from image 2)</li>
  <li>pixels outside the boundaries of the image (e.g. pixel at -1,-3)</li>
  <li>a pixel component that is unsigned or in a floating-point representation (e.g. 0.17836)</li>
  <li>a high-dynamic range pixel that can include negative values as well as values that exceed the quantum depth (e.g. -0.00716)</li>
</ul>

<p>In addition, some images include a clip mask that define which pixels are eligible to be updated.  Pixels outside the area defined by the clip mask remain untouched.</p>

<p>Given the varied image formats and image processing requirements, we implemented the ImageMagick <a href="#cache">pixel cache</a> to provide convenient access to any pixel on demand anywhere inside the image region and from any image in a sequence.  In addition, the pixel cache permits access to pixels outside the boundaries defined by the image (we call these <a href="#virtual-pixels">virtual pixels</a>).</p>

<p>In addition to pixels, images have a plethora of <a href="#properties">image properties and profiles</a>.  Properties include the well known items such as width, height, depth, and colorspace.  An image may have optional properties which might include the image author, a comment, a create date, and others.  Some images also include profiles for color management, or EXIF, IPTC, 8BIM, or XMP informational profiles.  ImageMagick provides command line options and programming methods to get, set, or view image properties or profiles or apply profiles.</p>

<p>ImageMagick has more than 325,000 lines of C code and optionally depends on several million lines of code in dependent libraries (e.g. JPEG, PNG, TIFF libraries).  Given that, one might expect a huge architecture document.  However, a great majority of image processing is simply accessing pixels and its metadata and our simple and elegant implementation makes this easy for the ImageMagick user.  We discuss the implementation of the pixel cache and getting and setting image properties and profiles in the next few sections.  Next, we discuss <a href="#coders">image coders</a> to read or write a particular image format followed by a few words on creating a <a href="#filters">filter</a> to access or update pixels based on your custom requirements.  In the final section, we discuss using ImageMagick within a <a href="#threads">thread</a> of execution.</p>

<div style="margin: auto;">
  <h2><a name="cache"></a>The Pixel Cache</h2>
</div>

<p>The ImageMagick pixel cache is a repository for image pixels with up to 5 channels.  The first 4 channels are stored contiguously and an optional second area follows with 1 channel.  The channels are at the depth specified when ImageMagick was built.  The channel depths are 8 bits-per-pixel for the Q8 version of ImageMagick, 16 bits-per-pixel for the the Q16 version, and 32 bits-per-pixel for the Q32 version.  By default pixel components are unsigned quantities, however, if you use the <a href="../www/high-dynamic-range.html" target="300562000">high dynamic-range</a> version of ImageMagick, the components are 32-bit floating point. The primary 4 channels can hold any value but typically contain red, green, blue, and alpha intensities or cyan, magenta, yellow, and alpha intensities.  The optional fifth channel contains the colormap indexes for colormapped images or the black channel for CMYK images.  The pixel cache storage may be anonymous memory mapped memory, heap memory, disk-backed memory mapped, or on disk.  The pixel cache is reference-counted.  Only the cache properties are copied when the cache is cloned.  The cache pixels are subsequently copied when you signal your intention to update any of the pixels.</p>

<h5>Create the Pixel Cache</h5>

<p>The pixel cache is associated with an image when it is created and it is initialized when you try to get or put pixels.  Here are three common methods to associate a pixel cache with an image:</p>

<ul>
  <li>Create an image canvas initialized to the background color:
<pre class="code">
  image=AllocateImage(image_info);
  if (SetImageExtent(image,640,480) == MagickFalse)
    { /* an exception was thrown */ }
  (void) QueryMagickColor("red",&amp;image->background_color,&amp;image->exception);
  SetImageBackgroundColor(image);
</pre></li>
  <li>Create an image from a JPEG image on disk:
<pre class="code">
  (void) strcpy(image_info->filename,"image.jpg"):
  image=ReadImage(image_info,exception);
  if (image == (Image *) NULL)
    { /* an exception was thrown */ }
</pre></li>
  <li>Create an image from a memory based image:
<pre class="code">
  image=BlobToImage(blob_info,blob,extent,exception);
  if (image == (Image *) NULL)
    { /* an exception was thrown */ }
</pre></li>
</ul>

<p>In our discussion of the pixel cache we use the <a href="../www/magick-core.html" target="917538919">MagickCore API</a> to illustrate our points, however, the principles are the same for other program interfaces to ImageMagick.</p>

<p>When the pixel cache is initialized, pixels are scaled from whatever bit depth they originated from to that required by the pixel cache.  For example, a 1-channel 1-bit monochrome PBM image is scaled to a 4 channel 8-bit RGBA image, if you are using the Q8 version of ImageMagick, and 16-bit RGBA for the Q16 version.  You can determine which version you have with this command: </p>

<pre class="text">
  -> identify -version
  Version: ImageMagick 6.4.2 05/01/08 Q16 http://www.imagemagick.org
</pre>

<p>As you can see, the convenience of the pixel cache sometimes comes with a tradeoff in storage and speed.</p>

<h5>Access the Pixel Cache</h5>

<p>Once the pixel cache is associated with an image, you typically want to get, update, or put pixels into it.  Use these methods to access the pixels in the cache:</p>

<ul>
  <li><a href="../www/api/cache.html#AcquireImagePixels" target="1272033595">AcquireImagePixels()</a> gets pixels that you do not intend to modify</li>
  <li><a href="../www/api/cache.html#GetImagePixels" target="30370354">GetImagePixels()</a> gets pixels that you intend to modify</li>
  <li><a href="../www/api/cache.html#SetImagePixels" target="1625010378">SetImagePixels()</a> set pixels that you intend to modify</li>
  <li><a href="../www/api/cache.html#SyncImagePixels" target="365330234">SyncImagePixels()</a> update the pixel cache with any modified pixels</li>
</ul>

<p>Here is a typical <a href="../www/magick-core.html" target="173325053">MagickCore</a> code snippet for manipulating pixels in the pixel cache.  In our example we copy pixels from the input image to the output image and decrease the intensity by 10%:</p>

<div class="viewport">
<pre class="code">
  long
    x,
    y;

  const PixelPacket
    *p;

  PixelPacket
    *q;

  destination=CloneImage(source,0,0,MagickTrue,exception);
  if (destination  == (Image *) NULL)
    { /* an exception was thrown */ }
  for (y=0; y &lt; (long) source->rows; y++)
  {
    p=AcquireImagePixels(source,0,y,source->columns,1);
    q=GetImagePixels(destination,0,y,destination->columns,1);
    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL)
      break;
    for (x=0; x &lt; (long) source->columns; x++)
    {
      q->red=90*p->red/100;
      q->green=90*p->green/100;
      q->blue=90*p->blue/100;
      q->opacity=90*p->opacity/100;
      p++;
      q++;
    }
    if (SyncImagePixels(destination) == MagickFalse)
      break;
  }
  if (y &lt; (long) source->rows)
    { /* an exception was thrown */ }
</pre>
</div>

<p>When we first create the destination image by cloning the source image, the pixel cache pixels are not copied.  They are only copied when you signal your intentions to modify the pixel cache by calling <a href="../www/api/cache.html#GetImagePixels" target="264243913">GetImagePixels()</a>. Use <a href="../www/api/cache.html#SetImagePixels" target="1558303082">SetImagePixels()</a> instead if you want to set new pixel values rather than update existing ones.  Finally, use <a href="../www/api/cache.html#SyncImagePixels" target="895120902">SyncImagePixels()</a> to ensure any pixel changes are pushed to the pixel cache.</p>

<p>Recall how we mentioned that the indexes of a colormapped image or the black channel of a CMYK image are stored separately.  We use  <a href="../www/api/cache.html#AcquireIndexes" target="1958823736">AcquireIndexes()</a> (we want to read the indexes) or <a href="../www/api/cache.html#GetIndexes" target="1044923833">GetIndexes()</a> (we intend to update the indexes) to gain access to this channel.  For example, to print the colormap indexes, use:</p>

<pre class="code">
  const IndexPacket
    *indexes;

  for (y=0; y &lt; (long) source->rows; y++)
  {
    p=AcquireImagePixels(source,0,y,source->columns,1);
    if (p == (const PixelPacket *) NULL)
      break;
    indexes=AcquireIndexes(source);
    for (x=0; x &lt; (long) source->columns; x++)
      (void) printf("%d\n",indexes[x];
  }
  if (y &lt; (long) source->rows)
    /* an exception was thrown */
</pre>

<p>The pixel cache manager decides whether to give you direct or indirect access to the image pixels.  In some cases the pixels are staged to an intermediate buffer-- and that is why you must call SyncImagePixels() to ensure this buffer is <em>pushed</em> out to the pixel cache to guarantee the corresponding pixels in the cache are updated.  For this reason we recommend that you only acquire, get, or set a scanline or a few scanlines of pixels at a time.  However, you can get any rectangular region of pixels you want.  GetImagePixels() requires that the region you request is within the bounds of the image area.  For a 640 by 480 image, you can get a scanline of 640 pixels but if you ask for 641 pixels, an exception is returned.  AcquireImagePixels() does not have this constraint.  For example,</p>

<pre class="code">
  p=AcquireImagePixels(source,-3,3,source->columns+7,7);
</pre>

<p>gives you the pixels you asked for without complaint, even though some are not within the confines of the image region.</p>

<h5><a name="virtual-pixels"></a>Virtual Pixels</h5>

<p>We refer to pixels outside the image region as <em>virtual pixels</em>. Their value is defined by the <a href="../www/api/cache.html#SetImageVirtualPixelMethod" target="136976591">SetImageVirtualPixelMethod()</a> from the MagickCore API or <a href="../www/command-line-options.html#virtual-pixel" target="584147006">-virtual-pixel</a> option from the command line.  The methods include:</p>

<pre class="text">
  background:  The area surrounding the image is the background color.
  dither:      Use a dithered pattern to choose a pixel in a 32x32 neighborhood.
  edge:        Extend the edge pixel toward infinity.
  mirror:      Mirror the image.
  random:      Choose a random pixel from the image.
  tile:        Tile the image (default).
  transparent: The area surrounding the image is transparent blackness.
</pre>

<p>There are a plethora of image processing algorithms that require a neighborhood of pixels about a pixel of interest.  There is typically a caveat concerning how to handle pixels around the image boundaries, known as edge pixels.  With virtual pixels, you do not need to concern yourself about special edge processing other than choosing  which virtual pixel method that is most appropriate for your algorithm.</p>

<h5>Cache Storage and Resource Requirements</h5>

<p>We mentioned previously that this simple and elegant design of the ImageMagick pixel cache comes at a cost in terms of storage and processing speed.  The pixel cache storage requirements scales with the area of the image and the bit depth of the pixel components.  For example, if we have a 640 by 480 image and we're using the Q16 version of ImageMagick, the pixel cache consumes image <em>width * height * bit-depth / 8 * channels</em> bytes or approximately 2.3 megabytes (i.e. 640 * 480 * 2 * 4).  Not too bad, but what if your image is 25000 by 25000 pixels?  The pixel cache requires approximately 4.7 gigabytes of storage.  Ouch.  ImageMagick accounts for possible huge storage requirements by caching large images to disk rather than memory.  Typically the pixel cache is stored in memory using anonymous memory mapping. If anonymous memory is exhausted, pixels are stored in heap memory; if heap memory is exhausted, we create the pixel cache on disk and attempt to memory-map it; and if memory-map memory is exhausted, we simply use standard disk I/O.  Disk is cheap but it is also very slow, upwards of 1000 times slower than memory.  We can get some speed improvements, up to 5 times, if we use memory mapping to the disk-based cache.  These decisions about storage are made <em>automagically</em> by the pixel cache manager negotiating with the operating system.  However, you can influence how the pixel cache manager allocates the pixel cache with <em>cache resource limits</em>.  The limits include:</p>

<ul>
  <dt>files</dt>
  <dd>maximum number of open pixel cache files.  When this limit is exceeded, any subsequent pixels cached to disk are closed and reopened on demand. This behavior permits a large number of images to be accessed simultaneously on disk, but with a speed penalty due to repeated open/close calls.</dd>
  <dt>area</dt>
  <dd>maximum area in bytes of any one image that can reside in the pixel cache memory.  If this limit is exceeded, the image is automatically cached to disk.</dd>
  <dt>memory</dt>
  <dd>maximum amount of memory in bytes to allocate for the pixel cache from the anonymous mapped memory or the heap.</dd>
  <dt>map</dt>
  <dd>maximum amount of memory map in bytes to allocate for the pixel cache.</dd>
  <dt>disk</dt>
  <dd>maximum amount of disk space in bytes permitted for use by the pixel cache.  If this limit is exceeded, the pixel cache is not created and a fatal exception is thrown.</dd>
</ul>

<p>To determine the current setting of these limits, use this command:</p>

<pre class="text">
  -> identify -list resource
  File       Area     Memory        Map       Disk
  ------------------------------------------------
   768        2gb      1.5gb        8gb        4eb
</pre>

<p>You can set these limits either with  <a href="../www/resources.html#environment" target="108007133">environment variables</a>, the <a href="../www/command-line-options.html#limit" target="815117741">-limit</a> command line option, or the <a href="../www/api/resource.html#SetMagickResourceLimit" target="665757103">SetMagickResourceLimit()</a> MagickCore API method. As an example, our online web interface to ImageMagick, <a href="http://www.imagemagick.org/MagickStudio/scripts/MagickStudio.cgi" target="971245436">ImageMagick Studio</a>, has an area limit of 64 megabytes, a memory limit of 128 megabytes and a map limit of 256 megabytes and a disk limit of 1 gigabytes.  Since we process multiple simultaneous sessions, we don't want any one session consuming all the available memory.  Instead large images are cached to disk.  If the image is too large and exceeds the pixel cache disk limit, the program exits.</p>

<p>Note, the cache limits are global, meaning if you create several images, the combined resource requirements are compared to the limit to determine the pixel cache storage disposition.</p>

<h5>Cache Views</h5>

<p>AcquireImagePixels(), GetImagePixels(), SetImagePixels(), and SyncImagePixels() from the MagickCore API can only deal with one pixel cache area per image at a time.  Suppose you want to access the first and last scanline from the same image at the same time?  The solution is to use a <em>cache view</em>.  A cache view permits you to access as many areas simultaneously in the pixel cache as you require.  The cache view <a href="../www/api/cache-view.html" target="388317411">methods</a> behave like the previous methods except you must first open a view and close it when you are finished with it. Here is a snippet of MagickCore that permits us to access two areas of an image simultaneously:</p>

<pre class="code">
  ViewInfo
    *view_1,
    *view_2;

  view_1=OpenCacheView(source);
  view_2=OpenCacheView(source);
  for (y=0; y &lt; (long) source->rows; y++)
  {
    u=AcquireCacheViewPixels(view_1,0,y,source->columns,1);
    v=AcquireCacheViewPixels(view_2,0,source->rows-y-1,source->columns,1);
    if ((u == (const PixelPacket *) NULL) || (v == (const PixelPacket *) NULL))
      break;
    for (x=0; x &lt; (long) source->columns; x++)
    {
      /* do something with u &amp; v here */
    }
  }
  view_1=CloseCacheView(view_1);
  view_2=CloseCacheView(view_2);
  if (y &lt; (long) source->rows)
    { /* an exception was thrown */ }
</pre>

<h5>Magick Persistent Cache Format</h5>

<p>Recall that each image format is decoded by ImageMagick and the pixels are deposited in the pixel cache.  If you write an image, the pixels are read from the pixel cache and encoded as required by the format you are writing (e.g. GIF, PNG, etc.).  The Magick Persistent Cache (MPC) format is designed to eliminate the overhead of decoding and encoding pixels to and from an image format.  MPC writes two files.  One, with the extension <kbd>.mpc</kbd>, retains all the properties associated with the image or image sequence (e.g. width, height, colorspace, etc.) and the second, with the extension <kbd>.cache</kbd>, is the pixel cache in the native format.  When reading an MPC image file, ImageMagick reads the image properties and memory maps the pixel cache on disk eliminating the need for decoding the image pixels.  The tradeoff is in disk space.  MPC is generally larger in file size than most other image formats.</p>

<h5>Best Practices</h5>

<p>Although you can request any pixel from the pixel cache, any block of pixels, any scanline, multiple scanlines, any row, or multiple rows with the AcquireImagePixels(), GetImagePixels(), SetImagePixels, AcquireCacheViewPixels(), GetCacheViewPixels(), and SetCacheView() methods, ImageMagick is optimized to return a few pixels or a few pixels rows at at time.  There are additional optimizations if you request a single scanline or a few scanlines at a time.  These methods also permit random access to the pixel cache, however, ImageMagick is optimized for sequential access.</p>

<p>If you update pixels returned from GetImagePixels() or GetCacheViewPixels(), don't forget to call SyncImageCache() or SyncCacheView() respectively to ensure your changes are synchronized with the pixel cache.</p>

<p>Use SetImagePixels() or SetCacheView() if you are setting an initial pixel value.  The GetImagePixels() or GetCacheViewPixels() method reads pixels from the cache and if you are setting an initial pixel value, this read is unnecessary. Don't forget to call SyncImagePixels() or SyncCacheView() respectively to push your updates to the pixel cache.</p>

<p>AcquireImagePixels(), GetImagePixels(), SetImagePixels(), and SyncImagePixels() are slightly more efficient than their cache view counter-parts.  However, cache views are required if you need access to more than one region of the image simultaneously or if more than one <a href="#threads">thread of execution</a> is accessing the image.</p>

<p>You can request pixels outside the bounds of the image with AcquireImagePixels() or AcquireCacheViewPixels(), however, it is more efficient to request pixels within the confines of the image region.</p>

<p>Although you can force the pixel cache to disk using appropriate resource limits, disk access can be upwards of 1000 times slower than memory access.  For fast, efficient, access to the pixel cache, try to keep the pixel cache in anonymous memory mapped or heap memory.</p>

<p>The ImageMagick Q16 version of ImageMagick permits you to read and write 16 bit images without scaling but the pixel cache consumes twice as much resources as the Q8 version.  If your system has constrained memory or disk resources, consider the Q8 version of ImageMagick.  In addition, the Q8 version is typically faster than the Q16 version.</p>

<p>A great majority of image formats and algorithms restrict themselves to a fixed range of pixel values from 0 to some maximum value, for example, the Q16 version of ImageMagick permit intensities from 0 to 65535.  High dynamic-range imaging (HDRI), however, permits a far greater dynamic range of exposures (i.e. a large difference between light and dark areas) than standard digital imaging techniques. HDRI accurately represents the wide range of intensity levels found in real scenes ranging from the brightest direct sunlight to the deepest darkest shadows.  Enable <a href="../www/high-dynamic-range.html" target="1944429743">HDRI</a> at ImageMagick build time to deal with high dynamic-range images, but be mindful that each pixel component is a 32-bit floating point value.</p>

<p>If you are dealing with large images, make sure the pixel cache is written to a disk area with plenty of free space.  Under Unix, this is typically <kbd>/tmp</kbd> and for Windows, <kbd>c:/temp</kbd>.  You can tell ImageMagick to write the pixel cache to an alternate location with the MAGICK_TMPDIR environment variable.  For example,</p>

<pre class="text">
  export MAGICK_TMPDIR=/data/magick
</pre>

<p>If you plan on processing the same image many times, consider the MPC format.  Reading a MPC image has near-zero overhead because its in the native pixel cache format eliminating the need for decoding the image pixels.  Here is an example:</p>

<pre class="text">
  convert image.tif image.mpc
  convert image.mpc -crop 100x100+0+0 +repage 1.png
  convert image.mpc -crop 100x100+100+0 +repage 2.png
  convert image.mpc -crop 100x100+200+0 +repage 3.png
  ...
</pre>

<p>MPC is ideal for web sites.  It reduces the overhead of reading and writing an image.  We use it exclusively at our <a href="http://www.imagemagick.org/MagickStudio/scripts/MagickStudio.cgi" target="1884275715">online image studio</a>.</p>

<div style="margin: auto;">
  <h2><a name="stream"></a>Streaming Pixels</h2>
</div>

<p>ImageMagick provides for streaming pixels as they are read from or written to an image.  This has several advantages over the pixel cache.  The time and resources consumed by the pixel cache scale with the area of an image, whereas the pixel stream resources scale with the width of an image.  The disadvantage is the pixels must be consumed as they are streamed so there is no persistence.</p>

<p>Use <a href="../www/api/stream.html#ReadStream" target="1643297414">ReadStream()</a> or <a href="../www/api/stream.html#WriteStream" target="165704406">WriteStream()</a> with an appropriate callback method in your MagickCore program to consume the pixels as they are streaming.  Here's an abbreviated example of using ReadStream:</p>

<pre class="code">
static size_t StreamHandler(const Image *image,const void *pixels,
  const size_t columns)
{
  /* process pixels here */
  return(columns);
}

...
/* invoke the pixel stream here */
image=ReadStream(image_info,&StreamHandler,exception);
</pre>

<p>We also provide a lightweight tool, <a name="stream"></a><a href="../www/stream.html">stream</a>, to stream one or more pixel components of the image or portion of the image to your choice of storage formats.  It writes the pixel components as they are read from the input image a row at a time making <a name="stream"></a><a href="../www/stream.html">stream</a> desirable when working with large images or when you require raw pixel components.</p>

<div style="margin: auto;">
  <h2><a name="properties"></a>Image Properties and Profiles</h2>
</div>

<p>Images have metadata associated with them in the form of properties (e.g. width, height, description, etc.) and profiles (e.g. EXIF, IPTC, color management).  ImageMagick provides convenient methods to get, set, or update image properties and get, set, update, or apply profiles.  Some of the more popular image properties are associated with the Image structure in the MagickCore API.  For example:</p>

<pre class="code">
  (void) printf("image width: %lu, height: %lu\n",image->columns,image->rows);
</pre>

<p>For a great majority of image properties, such as an image comment or description, we use the <a href="../www/api/property.html#GetImageProperty" target="1520953175">GetImageProperty()</a> and <a href="../www/api/property.html#SetImageProperty" target="323174441">SetImageProperty()</a> methods.  Here we set a property and fetch it right back:</p>

<pre class="code">
  const char
    *comment;

  (void) SetImageProperty(image,"comment","This space for rent");
  comment=GetImageProperty(image,"comment");
  if (comment == (const char *) NULL)
    (void) printf("Image comment: %s\n",comment);
</pre>

<p>Image profiles are handled with <a href="../www/api/profile.html#GetImageProfile" target="1824339917">GetImageProfile()</a>, <a href="../www/api/profile.html#SetImageProfile" target="1131384890">SetImageProfile()</a>, and <a href="../www/api/profile.html#ProfileImage" target="1519368854">ProfileImage()</a> methods.  Here we set a profile and fetch it right back:</p>

<pre class="code">
  StringInfo
    *profile;

  profile=AcquireStringInfo(length);
  SetStringInfoDatum(profile,my_exif_profile);
  (void) SetImageProfile(image,"EXIF,profile);
  DestroyStringInfo(profile);
  profile=GetImageProfile(image,"EXIF");
  if (profile != (StringInfo *) NULL)
    (void) PrintStringInfo(stdout,"EXIF",profile);
</pre>

<div style="margin: auto;">
  <h2><a name="coders"></a>Image Coders</h2>
</div>

<p>An image coder is responsible for registering, optionally classifying, optionally reading, optionally writing, and unregistering one image format (e.g.  PNG, GIF, JPEG, etc.).  Registering an image coder alerts ImageMagick a particular format is available to read or write.  While unregistering tells ImageMagick the format is no longer available.  The classifying method looks at the first few bytes of an image and decides if the image is in the expected format.  The reader sets the image size, colorspace, and other properties and loads the pixel cache with the pixels.  The reader returns a null image and an exception if an error occurs or returns a single image or an image sequence if the format supports multiple images per file.  The writer does the reverse.  It takes the image properties and unloads the pixel cache and writes them as required by the image format.</p>

<p>The modular design of the image coder makes it relatively easy to support new formats.  Here is a complete image coder with the exception of the classification method:</p>

<div class="viewport">
<pre class="code">
  /*
    Include declarations.
  */
  #include "magick/studio.h"
  #include "magick/blob.h"
  #include "magick/blob-private.h"
  #include "magick/colorspace.h"
  #include "magick/exception.h"
  #include "magick/exception-private.h"
  #include "magick/image.h"
  #include "magick/image-private.h"
  #include "magick/list.h"
  #include "magick/magick.h"
  #include "magick/memory_.h"
  #include "magick/monitor.h"
  #include "magick/quantum.h"
  #include "magick/static.h"
  #include "magick/string_.h"

  /*
    Forward declarations.
  */
  static MagickBooleanType
    WriteAVSImage(const ImageInfo *,Image *);

  /*
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %   R e a d A V S I m a g e                                                   %
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %
  %  ReadAVSImage() reads an AVS X image file and returns it.  It
  %  allocates the memory necessary for the new Image structure and returns a
  %  pointer to the new image.
  %
  %  The format of the ReadAVSImage method is:
  %
  %      Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception)
  %
  %  A description of each parameter follows:
  %
  %    o image_info: The image info.
  %
  %    o exception: return any errors or warnings in this structure.
  %
  */

  static inline size_t CheckOverflowException(const Image *image,
    const size_t extend)
  {
    if ((extend*image->columns) &lt; (size_t) image->columns)
      ThrowMagickFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
        image->filename);
    return(extend*image->columns);
  }

  static Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception)
  {
    Image
      *image;

    long
      y;

    MagickBooleanType
      status;

    register long
      x;

    register PixelPacket
      *q;

    register unsigned char
      *p;

    ssize_t
      count;

    size_t
      length;

    unsigned char
      *pixels;

    unsigned long
      height,
      width;

    /*
      Open image file.
    */
    assert(image_info != (const ImageInfo *) NULL);
    assert(image_info->signature == MagickSignature);
    if (image_info->debug != MagickFalse)
      (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
        image_info->filename);
    assert(exception != (ExceptionInfo *) NULL);
    assert(exception->signature == MagickSignature);
    image=AllocateImage(image_info);
    status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
    if (status == MagickFalse)
      {
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    /*
      Read AVS X image.
    */
    width=ReadBlobMSBLong(image);
    height=ReadBlobMSBLong(image);
    if ((width == ~0UL) || (height == ~0UL))
      ThrowReaderException(CorruptImageError,"ImproperImageHeader");
    do
    {
      /*
        Convert AVS raster image to pixel packets.
      */
      image->columns=width;
      image->rows=height;
      image->depth=8;
      if ((image_info->ping != MagickFalse) &amp;&amp; (image_info->number_scenes != 0))
        if (image->scene >= (image_info->scene+image_info->number_scenes-1))
          break;
      length=CheckOverflowException(image,4);
      pixels=(unsigned char *) AcquireMagickMemory(length);
      if (pixels == (unsigned char *) NULL)
        ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
      for (y=0; y &lt; (long) image->rows; y++)
      {
        count=ReadBlob(image,length,pixels);
        if ((size_t) count != length)
          ThrowReaderException(CorruptImageError,"UnableToReadImageData");
        p=pixels;
        q=SetImagePixels(image,0,y,image->columns,1);
        if (q == (PixelPacket *) NULL)
          break;
        for (x=0; x &lt; (long) image->columns; x++)
        {
          q->opacity=(Quantum) (QuantumRange-ScaleCharToQuantum(*p++));
          q->red=ScaleCharToQuantum(*p++);
          q->green=ScaleCharToQuantum(*p++);
          q->blue=ScaleCharToQuantum(*p++);
          if (q->opacity != OpaqueOpacity)
            image->matte=MagickTrue;
          q++;
        }
        if (SyncImagePixels(image) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &amp;&amp;
              (QuantumTick(y,image->rows) != MagickFalse))
            {
              status=image->progress_monitor(LoadImageTag,y,image->rows,
                image->client_data);
              if (status == MagickFalse)
                break;
            }
      }
      pixels=(unsigned char *) RelinquishMagickMemory(pixels);
      if (EOFBlob(image) != MagickFalse)
        {
          ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
            image->filename);
          break;
        }
      /*
        Proceed to next image.
      */
      if (image_info->number_scenes != 0)
        if (image->scene >= (image_info->scene+image_info->number_scenes-1))
          break;
      width=ReadBlobMSBLong(image);
      height=ReadBlobMSBLong(image);
      if ((width != ~0UL) &amp;&amp; (height != ~0UL))
        {
          /*
            Allocate next image structure.
          */
          AllocateNextImage(image_info,image);
          if (GetNextImageInList(image) == (Image *) NULL)
            {
              image=DestroyImageList(image);
              return((Image *) NULL);
            }
          image=SyncNextImageInList(image);
          if (image->progress_monitor != (MagickProgressMonitor) NULL)
            {
              status=image->progress_monitor(LoadImagesTag,TellBlob(image),
                GetBlobSize(image),image->client_data);
              if (status == MagickFalse)
                break;
            }
        }
    } while ((width != ~0UL) &amp;&amp; (height != ~0UL));
    CloseBlob(image);
    return(GetFirstImageInList(image));
  }

  /*
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %   R e g i s t e r A V S I m a g e                                           %
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %
  %  RegisterAVSImage() adds properties for the AVS X image format to the list
  %  of supported formats.  The properties include the image format tag, a
  %  method to read and/or write the format, whether the format supports the
  %  saving of more than one frame to the same file or blob, whether the format
  %  supports native in-memory I/O, and a brief description of the format.
  %
  %  The format of the RegisterAVSImage method is:
  %
  %      RegisterAVSImage(void)
  %
  */
  ModuleExport void RegisterAVSImage(void)
  {
    MagickInfo
      *entry;

    entry=SetMagickInfo("AVS");
    entry->decoder=(DecodeImageHandler *) ReadAVSImage;
    entry->encoder=(EncodeImageHandler *) WriteAVSImage;
    entry->description=ConstantString("AVS X image");
    entry->module=ConstantString("AVS");
    (void) RegisterMagickInfo(entry);
  }

  /*
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %   U n r e g i s t e r A V S I m a g e                                       %
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %
  %  UnregisterAVSImage() removes format registrations made by the
  %  AVS module from the list of supported formats.
  %
  %  The format of the UnregisterAVSImage method is:
  %
  %      UnregisterAVSImage(void)
  %
  */
  ModuleExport void UnregisterAVSImage(void)
  {
    (void) UnregisterMagickInfo("AVS");
  }

  /*
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %   W r i t e A V S I m a g e                                                 %
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %
  %  WriteAVSImage() writes an image to a file in AVS X image format.
  %
  %  The format of the WriteAVSImage method is:
  %
  %      MagickBooleanType WriteAVSImage(const ImageInfo *image_info,Image *image)
  %
  %  A description of each parameter follows.
  %
  %    o image_info: The image info.
  %
  %    o image:  The image.
  %
  */
  static MagickBooleanType WriteAVSImage(const ImageInfo *image_info,Image *image)

   MagickBooleanType
     status;

   MagickOffsetType
     scene;

   register const PixelPacket
     *p;

   register long
     x,
     y;

   register unsigned char
     *q;

   unsigned char
     *pixels;

   /*
     Open output image file.
   */
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&amp;image->exception);
   if (status == MagickFalse)
     return(status);
   scene=0;
   do
   {
     /*
       Write AVS header.
     */
     if (image_info->colorspace == UndefinedColorspace)
       (void) SetImageColorspace(image,RGBColorspace);
     (void) WriteBlobMSBLong(image,image->columns);
     (void) WriteBlobMSBLong(image,image->rows);
     /*
       Allocate memory for pixels.
     */
     pixels=(unsigned char *)
       AcquireMagickMemory((size_t) image->columns*sizeof(PixelPacket));
     if (pixels == (unsigned char *) NULL)
       ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
     /*
       Convert MIFF to AVS raster pixels.
     */
     for (y=0; y &lt; (long) image->rows; y++)
     {
       p=AcquireImagePixels(image,0,y,image->columns,1,&amp;image->exception);
       if (p == (PixelPacket *) NULL)
         break;
       q=pixels;
       for (x=0; x &lt; (long) image->columns; x++)
       {
         *q++=ScaleQuantumToChar(QuantumRange-(image->matte != MagickFalse ?
           p->opacity : OpaqueOpacity));
         *q++=ScaleQuantumToChar(p->red);
         *q++=ScaleQuantumToChar(p->green);
         *q++=ScaleQuantumToChar(p->blue);
         p++;
       }
       (void) WriteBlob(image,(size_t) (q-pixels),pixels);
       if (image->previous == (Image *) NULL)
         if ((image->progress_monitor != (MagickProgressMonitor) NULL) &amp;&amp;
             (QuantumTick(y,image->rows) != MagickFalse))
           {
             status=image->progress_monitor(SaveImageTag,y,image->rows,
               image->client_data);
             if (status == MagickFalse)
               break;
           }
     }
     pixels=(unsigned char *) RelinquishMagickMemory(pixels);
     if (GetNextImageInList(image) == (Image *) NULL)
       break;
     image=SyncNextImageInList(image);
     if (image->progress_monitor != (MagickProgressMonitor) NULL)
       {
         status=image->progress_monitor(SaveImagesTag,scene,
           GetImageListLength(image),image->client_data);
         if (status == MagickFalse)
           break;
       }
     scene++;
   } while (image_info->adjoin != MagickFalse);
   CloseBlob(image);
   return(MagickTrue);
</pre>
</div>

<div style="margin: auto;">
  <h2><a name="filters"></a>Custom Image Filters</h2>
</div>

<p>ImageMagick provides a convenient mechanism for adding your own custom image processing algorithms.  We call these image filters and they are invoked from the command line with the <a href="../www/command-line-options.html#process" target="magick-options">-process</a> option or from the MagickCore API method <a href="../www/api/module.html#ExecuteModuleProcess" target="1357763916">ExecuteModuleProcess()</a>.</p>

<p>ImageMagick includes a sample <a href="../www/source/analyze.c">custom filter</a> listed here.  It computes a few statistics such as the brightness and saturation mean and standard-deviation.</p>

<div class="viewport">
<pre class="code">
  #include &lt;stdio.h>
  #include &lt;stdlib.h>
  #include &lt;string.h>
  #include &lt;time.h>
  #include &lt;assert.h>
  #include &lt;math.h>
  #include "magick/MagickCore.h"

  /*
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %   a n a l y z e I m a g e                                                   %
  %                                                                             %
  %                                                                             %
  %                                                                             %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %
  %  analyzeImage() computes the brightness and saturation mean and standard
  %  deviation and stores these values as properties of the image.
  %
  %  The format of the analyzeImage method is:
  %
  %      unsigned long analyzeImage(Image *images,const int argc,char **argv,ExceptionInfo *exception)
  %
  %  A description of each parameter follows:
  %
  %    o image: The address of a structure of type Image.
  %
  %    o argc: Specifies a pointer to an integer describing the number of
  %      elements in the argument vector.
  %
  %    o argv: Specifies a pointer to a text array containing the command line
  %      arguments.
  %
  %    o exception: Return any errors or warnings in this structure.
  %
  */
  ModuleExport unsigned long analyzeImage(Image **images,const int argc,char **argv,ExceptionInfo *exception)
  {
    char
      text[MaxTextExtent];
  
    double
      area,
      brightness_mean,
      brightness_standard_deviation,
      brightness_sum_x,
      brightness_sum_x2,
      saturation_mean,
      saturation_standard_deviation,
      saturation_sum_x,
      saturation_sum_x2;
  
    double
      brightness,
      hue,
      saturation;
  
    Image
      *image;
  
    long
      y;
  
    register const PixelPacket
      *p;
  
    register long
      x;
  
    assert(images != (Image **) NULL);
    assert(*images != (Image *) NULL);
    assert((*images)->signature == MagickSignature);
    for (image=(*images); image != (Image *) NULL; image=GetNextImageInList(image))
    {
      brightness_sum_x=0.0;
      brightness_sum_x2=0.0;
      brightness_mean=0.0;
      brightness_standard_deviation=0.0;
      saturation_sum_x=0.0;
      saturation_sum_x2=0.0;
      saturation_mean=0.0;
      saturation_standard_deviation=0.0;
      area=0.0;
      for (y=0; y < (long) image->rows; y++)
      {
        p=AcquireImagePixels(image,0,y,image->columns,1,exception);
        if (p == (const PixelPacket *) NULL)
          break;
        for (x=0; x < (long) image->columns; x++)
        {
          ConvertRGBToHSB(p->red,p->green,p->blue,&hue,&saturation,&brightness);
          brightness*=QuantumRange;
          brightness_sum_x+=brightness;
          brightness_sum_x2+=brightness*brightness;
          saturation*=QuantumRange;
          saturation_sum_x+=saturation;
          saturation_sum_x2+=saturation*saturation;
          area++;
          p++;
        }
      }
      if (area &lt;= 0.0)
        break;
      brightness_mean=brightness_sum_x/area;
      (void) FormatMagickString(text,MaxTextExtent,"%g",brightness_mean);
      (void) SetImageProperty(image,"filter:brightness:mean",text);
      brightness_standard_deviation=sqrt(brightness_sum_x2/area-(brightness_sum_x/area*brightness_sum_x/area));
      (void) FormatMagickString(text,MaxTextExtent,"%g",brightness_standard_deviation);
      (void) SetImageProperty(image,"filter:brightness:standard-deviation",text);
      saturation_mean=saturation_sum_x/area;
      (void) FormatMagickString(text,MaxTextExtent,"%g",saturation_mean);
      (void) SetImageProperty(image,"filter:saturation:mean",text);
      saturation_standard_deviation=sqrt(saturation_sum_x2/area-(saturation_sum_x/area*saturation_sum_x/area));
      (void) FormatMagickString(text,MaxTextExtent,"%g",saturation_standard_deviation);
      (void) SetImageProperty(image,"filter:saturation:standard-deviation",text);
    }
    return(MagickImageFilterSignature);
  }
</pre>
</div>

<p>To invoke the custom filter from the command line, use this command:</p>

<pre class="text">
  -> convert logo: -process analyze -verbose info:
  Image: logo:
    Format: LOGO (ImageMagick Logo)
    Class: PseudoClass
    Geometry: 640x480
    ...
    Filter:brightness:mean: 61191
    Filter:brightness:standard-deviation: 11906
    Filter:saturation:mean: 6030
    Filter:saturation:standard-deviation: 16647
</pre>

<div style="margin: auto;">
 <h2><a name="threads"></a>Threads of Execution</h2>
</div>

<p>Many of ImageMagick's internal algorithms are threaded to take advantage of speed-ups offered by the dual and quad-core processor technologies. However, you are welcome to use ImageMagick algorithm in your threads of execution with the exception of the MagickCore AcquireImagePixels(), GetImagePixels(), SetImagePixels(), and SyncImagePixels() pixel cache methods.  These methods are intended for one thread of execution only. To access the pixel cache with more than one thread of execution, use a cache view.  We do this for the <a href="../www/api/composite.html#CompositeImage" target="93754674">CompositeImage()</a> method, for example.  Suppose we want to composite a single image over a different image in each thread of execution.  If we use AcquireImagePixels(), the results could be corrupt since multiple threads might be asking for different areas of the pixel cache simultaneously.  Instead we use AcquireCacheViewPixels() which creates a unique view for each thread of execution ensuring our program behaves properly regardless of how many threads are invoked.  The other program interfaces, such as the <a href="../www/magick-wand.html" target="1170950430">MagickWand API</a>, are completely thread safe so there are no special precautions for threads of execution.</p>

<p>Here is an example of how ImageMagick can take advantage of threads of execution with the OpenMP programming paradigm:</p>

<div class="viewport">
<pre class="code">
{
  long
    y;

  MagickBooleanType
    status;

  ViewInfo
    **image_view;

  status=MagickTrue;
  image_view=AcquireCacheViewThreadSet(image);
  #pragma omp parallel for
  for (y=0; y < (long) image->rows; y++)
  {
    register IndexPacket
      *indexes;
    
    register long
      id,
      x;
    
    register PixelPacket
      *q;
    
    id=GetCacheViewThreadId();
    q=GetCacheViewPixels(image_view[id],0,y,image->columns,1);
    if (q == (PixelPacket *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    indexes=GetCacheViewIndexes(image_view[id]);
    for (x=0; x < (long) image->columns; x++)
    {
      q->red= ...
      q->green= ...
      q->blue= ...
      q->opacity= ...
      if (indexes != (IndexPacket *) NULL)
        indexes[x]= ...
      q++;
    }
    if (SyncCacheView(image_view[id]) == MagickFalse)
      status=MagickFalse;
  }
  image_view=DestroyCacheViewThreadSet(image_view);
  if (status == MagickFalse)
    perror("something went wrong");
}
</pre>
</div>
      </td>
      <td id="margin" width="1%" height="100%" valign="top" align="right">&nbsp;</td>
    </tr>
  </tbody>
  </table>
  <div id="linkbar">
    <span id="linkbar-west">
      <font size="-1">
      <a href="http://www.downloadroute.com/" target="1658325916">Downloads and Opinions</a><!-- 200809010100 -->
      </font>
    </span>
    <span id="linkbar-east">
      <font size="-1">
      <a href="http://www.online-kredit-index.de/" target="1011293593">Kredit</a><!-- 200808010100 -->
      </font>
    </span>
    <span id="linkbar-center">
      <a href="http://www.imagemagick.org/discourse-server/" target="295500378">Discourse Server</a> &bull;
      <a href="../www/mailing-list.html">Mailing Lists</a> &bull;
      <a href="http://cafe.imagemagick.org" target="1688696271">Cafe</a> &bull;
    <a href="http://www.imagemagick.org/MagickStudio/scripts/MagickStudio.cgi" target="660830612">Studio</a>
    </span>
  </div>
  <div id="footer">
    <span id="footer-west">&copy; 1999-2008 ImageMagick Studio LLC</span>
  </div>
  <div style="clear: both; margin: 0; width: 100%; "></div>
</body>
</html>
