# Mensajes en español para GNU tar.
# Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
# Federico Rivas <frivas@arrakis.es>, 1997.
# Enrique Melero <melero@iprolink.ch>, 1997.
# Santiago Vila Doncel <sanvila@unex.es>, 1998, 1999, 2000, 2001, 2002, 2004.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU tar 1.15.1\n"
"Report-Msgid-Bugs-To: bug-tar@gnu.org\n"
"POT-Creation-Date: 2006-10-21 18:41+0300\n"
"PO-Revision-Date: 2004-12-27 20:45+0100\n"
"Last-Translator: Santiago Vila Doncel <sanvila@unex.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: lib/argmatch.c:135
#, c-format
msgid "invalid argument %s for %s"
msgstr "argumento %s inválido para %s"

#: lib/argmatch.c:136
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "argumento %s ambiguo para %s"

#: lib/argmatch.c:155
#, c-format
msgid "Valid arguments are:"
msgstr "Los argumentos válidos son:"

#: lib/argp-help.c:148
#, c-format
msgid "ARGP_HELP_FMT: %s value is less than or equal to %s"
msgstr ""

#: lib/argp-help.c:221
#, c-format
msgid "%.*s: ARGP_HELP_FMT parameter requires a value"
msgstr "%.*s: El parámetro ARGP_HELP_FMT necesita un valor"

#: lib/argp-help.c:227
#, fuzzy, c-format
msgid "%.*s: ARGP_HELP_FMT parameter must be positive"
msgstr "%.*s: El parámetro ARGP_HELP_FMT necesita un valor"

#: lib/argp-help.c:236
#, c-format
msgid "%.*s: Unknown ARGP_HELP_FMT parameter"
msgstr "%.*s: Parámetro ARGP_HELP_FMT desconocido"

#: lib/argp-help.c:248
#, c-format
msgid "Garbage in ARGP_HELP_FMT: %s"
msgstr "Incongruencia en ARGP_HELP_FMT: %s"

#: lib/argp-help.c:1229
msgid ""
"Mandatory or optional arguments to long options are also mandatory or "
"optional for any corresponding short options."
msgstr ""
"Los argumentos obligatorios u opcionales para las opciones largas son "
"también\n"
"obligatorios u opcionales para las opciones cortas correspondientes."

#: lib/argp-help.c:1622
msgid "Usage:"
msgstr "Modo de empleo:"

#: lib/argp-help.c:1626
msgid "  or: "
msgstr " o bien: "

#: lib/argp-help.c:1638
msgid " [OPTION...]"
msgstr " [OPCIÓN...]"

#: lib/argp-help.c:1665
#, c-format
msgid "Try `%s --help' or `%s --usage' for more information.\n"
msgstr "Pruebe `%s --help' o `%s --usage' para más información.\n"

# Por favor, no me digáis cómo se traduce bug.
# Gerardo lo ha visto traducido en un libro como "pulgas", y yo
# lo he visto como "chinche" en la "Investigación y Ciencia".
# Está claro que así no vamos a ninguna parte.
# Yo diría simplemente `fallos [ocultos]'. Es lo que significa, en realidad,
# en el contexto informático, razones históricas aparte de bichos anidando
# al calorcito de los tubos de vacío de los primeros computadores. gerardo
# De "ocultos" nada... Este vamos a dejarlo, ¿vale? sv
# Tú mandas, pero ¿cómo que de ocultos nada? Si no fueran ocultos, el progra-
# ma no vería la luz aún, ¿no? Pero observa que he puesto el `ocultos' entre
# corchetes. Yo pondría "bug -> fallo" simplemente. Comunicar fallos a... gerardo
# ¿Que no vería la luz si no fueran ocultos? Ja, ja, ja, ja...
# Mira por ejemplo en http://nl.debian.org/Bugs.
# ¿No tendría sentido catalogarlos entonces?
#
# Véase "A Bug's life".
#: lib/argp-help.c:1693 src/tar.c:1136
#, c-format
msgid "Report bugs to %s.\n"
msgstr "Comunicar bichos a %s.\n"

#: lib/argp-help.c:1912 lib/error.c:125
msgid "Unknown system error"
msgstr "Error del sistema desconocido"

#: lib/argp-parse.c:82 src/tar.c:717
#, fuzzy
msgid "give this help list"
msgstr "Da esta lista de ayuda"

#: lib/argp-parse.c:83 src/tar.c:718
#, fuzzy
msgid "give a short usage message"
msgstr "Da un mensaje de uso corto"

#: lib/argp-parse.c:84 src/tar.c:450 src/tar.c:452 src/tar.c:521
#: tests/genfile.c:126
msgid "NAME"
msgstr "NOMBRE"

#: lib/argp-parse.c:84
msgid "set the program name"
msgstr ""

#: lib/argp-parse.c:85
msgid "SECS"
msgstr ""

#: lib/argp-parse.c:86 src/tar.c:723
msgid "hang for SECS seconds (default 3600)"
msgstr ""

#: lib/argp-parse.c:143 src/tar.c:719
#, fuzzy
msgid "print program version"
msgstr "Muestra la versión del programa"

#: lib/argp-parse.c:159
#, c-format
msgid "(PROGRAM ERROR) No version known!?"
msgstr ""

#: lib/argp-parse.c:612
#, fuzzy, c-format
msgid "%s: Too many arguments\n"
msgstr "%s: la opción `%s' requiere un argumento\n"

#: lib/argp-parse.c:755
msgid "(PROGRAM ERROR) Option should have been recognized!?"
msgstr ""

#: lib/getopt.c:531 lib/getopt.c:547
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: la opción `%s' es ambigua\n"

#: lib/getopt.c:580 lib/getopt.c:584
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: la opción `--%s' no admite ningún argumento\n"

#: lib/getopt.c:593 lib/getopt.c:598
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: la opción `%c%s' no admite ningún argumento\n"

#: lib/getopt.c:641 lib/getopt.c:660 lib/getopt.c:976 lib/getopt.c:995
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: la opción `%s' requiere un argumento\n"

#: lib/getopt.c:698 lib/getopt.c:701
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opción no reconocida `--%s'\n"

#: lib/getopt.c:709 lib/getopt.c:712
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opción no reconocida `%c%s'\n"

#: lib/getopt.c:764 lib/getopt.c:767
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: lib/getopt.c:773 lib/getopt.c:776
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opción inválida -- %c\n"

#: lib/getopt.c:828 lib/getopt.c:844 lib/getopt.c:1048 lib/getopt.c:1066
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: lib/getopt.c:897 lib/getopt.c:913
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: la opción `-W %s' es ambigua\n"

#: lib/getopt.c:937 lib/getopt.c:955
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: la opción `-W %s' no admite ningún argumento\n"

#: lib/human.c:484
msgid "block size"
msgstr "tamaño del bloque"

#: lib/obstack.c:424 lib/obstack.c:426 lib/xalloc-die.c:35 src/extract.c:1361
msgid "memory exhausted"
msgstr "memoria agotada"

# FIXME: Intraducible.
#. TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.
#. Directly translating this to another language will not work, first because
#. %s itself is not translated.
#. Translate it as `%s: Function %s failed'.
#: lib/paxerror.c:58 lib/paxerror.c:71
#, c-format
msgid "%s: Cannot %s"
msgstr "%s: No se puede %s"

#. TRANSLATORS: %s after `Cannot' is a function name, e.g. `Cannot open'.
#. Directly translating this to another language will not work, first because
#. %s itself is not translated.
#. Translate it as `%s: Function %s failed'.
#: lib/paxerror.c:84
#, c-format
msgid "%s: Warning: Cannot %s"
msgstr "%s: Atención: No se puede %s"

#: lib/paxerror.c:93
#, c-format
msgid "%s: Cannot change mode to %s"
msgstr "%s: No se puede cambiar el modo a %s"

#: lib/paxerror.c:101
#, c-format
msgid "%s: Cannot change ownership to uid %lu, gid %lu"
msgstr "%s: No se puede cambiar el propietario a uid %lu, gid %lu"

#: lib/paxerror.c:127
#, c-format
msgid "%s: Cannot hard link to %s"
msgstr "%s: No se puede crear un enlace duro a %s"

#: lib/paxerror.c:179
#, fuzzy, c-format
msgid "%s: Read error at byte %s, while reading %lu byte"
msgid_plural "%s: Read error at byte %s, while reading %lu bytes"
msgstr[0] "%s: Error de lectura en el byte %s, leyendo %lu byte"
msgstr[1] "%s: Error de lectura en el byte %s, leyendo %lu bytes"

#: lib/paxerror.c:192
#, fuzzy, c-format
msgid "%s: Warning: Read error at byte %s, while reading %lu byte"
msgid_plural "%s: Warning: Read error at byte %s, while reading %lu bytes"
msgstr[0] "%s: Atención: Error de lectura en el byte %s, leyendo %lu byte"
msgstr[1] "%s: Atención: Error de lectura en el byte %s, leyendo %lu bytes"

#: lib/paxerror.c:211
#, c-format
msgid "%s: Read error at byte %s, reading %lu byte"
msgid_plural "%s: Read error at byte %s, reading %lu bytes"
msgstr[0] "%s: Error de lectura en el byte %s, leyendo %lu byte"
msgstr[1] "%s: Error de lectura en el byte %s, leyendo %lu bytes"

#: lib/paxerror.c:259
#, c-format
msgid "%s: Cannot seek to %s"
msgstr "%s: No se puede desplazar a %s"

#: lib/paxerror.c:275
#, c-format
msgid "%s: Warning: Cannot seek to %s"
msgstr "%s: Atención: No se puede desplazar a %s"

#: lib/paxerror.c:284
#, c-format
msgid "%s: Cannot create symlink to %s"
msgstr "%s: No se puede crear el enlace simbólico a %s"

#: lib/paxerror.c:349
#, c-format
msgid "%s: Wrote only %lu of %lu byte"
msgid_plural "%s: Wrote only %lu of %lu bytes"
msgstr[0] "%s: Sólo se escribieron %lu de %lu byte"
msgstr[1] "%s: Sólo se escribieron %lu de %lu bytes"

# FIXME. This might not always work. Is `%.*s' male or female? sv
#: lib/paxnames.c:132
#, c-format
msgid "Removing leading `%s' from member names"
msgstr "Eliminando la `%s' inicial de los nombres"

#: lib/paxnames.c:133
#, c-format
msgid "Removing leading `%s' from hard link targets"
msgstr "Eliminando la `%s' inicial de los objetivos de los enlaces"

# FIXME. This might not always work. Is `%.*s' male or female? sv
#: lib/paxnames.c:146
msgid "Substituting `.' for empty member name"
msgstr "Se sustituye `.' por el nombre vacío"

#: lib/paxnames.c:147
msgid "Substituting `.' for empty hard link target"
msgstr "Se sustituye `.' por un objetivo vacío de enlace duro"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  If the catalog has no translation,
#. locale_quoting_style quotes `like this', and
#. clocale_quoting_style quotes "like this".
#.
#. For example, an American English Unicode locale should
#. translate "`" to U+201C (LEFT DOUBLE QUOTATION MARK), and
#. should translate "'" to U+201D (RIGHT DOUBLE QUOTATION
#. MARK).  A British English Unicode locale should instead
#. translate these to U+2018 (LEFT SINGLE QUOTATION MARK) and
#. U+2019 (RIGHT SINGLE QUOTATION MARK), respectively.
#.
#. If you don't know what to put here, please see
#. <http://en.wikipedia.org/wiki/Quotation_mark#Glyphs>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:243
msgid "`"
msgstr "`"

#: lib/quotearg.c:244
msgid "'"
msgstr "'"

#: lib/rpmatch.c:70
msgid "^[yY]"
msgstr ""

#: lib/rpmatch.c:73
msgid "^[nN]"
msgstr ""

#: lib/rtapelib.c:299
#, c-format
msgid "exec/tcp: Service not available"
msgstr "exec/tcp: Servicio no disponible"

#: lib/rtapelib.c:303
#, c-format
msgid "stdin"
msgstr "entrada estándar (stdin)"

#: lib/rtapelib.c:306
#, c-format
msgid "stdout"
msgstr "salida estándar (stdout)"

#: lib/rtapelib.c:512
#, c-format
msgid "Cannot execute remote shell"
msgstr "No se puede ejecutar un shell remoto"

#: rmt/rmt.c:142
msgid "Input string too long"
msgstr ""

#: rmt/rmt.c:161
msgid "Number syntax error"
msgstr ""

#: rmt/rmt.c:180
msgid "rmtd: Cannot allocate buffer space\n"
msgstr "rmtd: No se puede asignar espacio para el búfer\n"

#: rmt/rmt.c:182
msgid "Cannot allocate buffer space"
msgstr "No se puede asignar espacio para el búfer"

#: rmt/rmt.c:304
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

#: rmt/rmt.c:308
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Manipulate a tape drive, accepting commands from a remote process.\n"
"\n"
"  --version  Output version info.\n"
"  --help     Output this help.\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN]\n"
"Manipula una unidad de cinta, aceptando órdenes de un proceso remoto.\n"
"\n"
"  --version  Muestra la versión.\n"
"  --help     Muestra esta ayuda.\n"

# Por favor, no me digáis cómo se traduce bug.
# Gerardo lo ha visto traducido en un libro como "pulgas", y yo
# lo he visto como "chinche" en la "Investigación y Ciencia".
# Está claro que así no vamos a ninguna parte.
# Yo diría simplemente `fallos [ocultos]'. Es lo que significa, en realidad,
# en el contexto informático, razones históricas aparte de bichos anidando
# al calorcito de los tubos de vacío de los primeros computadores. gerardo
# De "ocultos" nada... Este vamos a dejarlo, ¿vale? sv
# Tú mandas, pero ¿cómo que de ocultos nada? Si no fueran ocultos, el progra-
# ma no vería la luz aún, ¿no? Pero observa que he puesto el `ocultos' entre
# corchetes. Yo pondría "bug -> fallo" simplemente. Comunicar fallos a... gerardo
# ¿Que no vería la luz si no fueran ocultos? Ja, ja, ja, ja...
# Mira por ejemplo en http://nl.debian.org/Bugs.
# ¿No tendría sentido catalogarlos entonces?
#
# Véase "A Bug's life".
#: rmt/rmt.c:315
#, c-format
msgid ""
"\n"
"Report bugs to <%s>.\n"
msgstr ""
"\n"
"Comunicar bichos a <%s>.\n"

#: rmt/rmt.c:397
#, fuzzy
msgid "Seek offset error"
msgstr "Desplazamiento fuera de rango"

#: rmt/rmt.c:406 rmt/rmt.c:547 rmt/rmt.c:557
msgid "Seek offset out of range"
msgstr "Desplazamiento fuera de rango"

#: rmt/rmt.c:428
msgid "Seek direction out of range"
msgstr "Dirección de desplazamiento fuera de rango"

# FIXME. Este es el único eof en minúsculas.
#: rmt/rmt.c:472
msgid "rmtd: Premature eof\n"
msgstr "rmtd: Fin de fichero prematuro\n"

#: rmt/rmt.c:474
msgid "Premature end of file"
msgstr "Fin de fichero prematuro"

#: rmt/rmt.c:672
msgid "Garbage command"
msgstr "Orden ininteligible"

# ¿No es mejor "Total de bytes escritos: "?
# Suena más directo y más similar al original,
# "bytes escritos en total" suena demasiado complejo... Nicolás Lichtmaier.
# Suena algo extraño eso de "total de bytes". "en total" me suena
# mucho más natural. sv
#: src/buffer.c:317 src/buffer.c:326
#, fuzzy
msgid "Total bytes written"
msgstr "Bytes escritos en total: %s (%s, %s/s)\n"

#: src/buffer.c:324 src/buffer.c:338
msgid "Total bytes read"
msgstr ""

# ¿No es mejor "Total de bytes escritos: "?
# Suena más directo y más similar al original,
# "bytes escritos en total" suena demasiado complejo... Nicolás Lichtmaier.
# Suena algo extraño eso de "total de bytes". "en total" me suena
# mucho más natural. sv
#: src/buffer.c:328
#, fuzzy, c-format
msgid "Total bytes deleted: %s\n"
msgstr "Bytes escritos en total: %s (%s, %s/s)\n"

# Antes de que nadie diga nada:
#
# Si a alguien no le gusta la palabra tubería (que aparece en algunos
# libros sobre MS-DOS y es la que venimos usando desde el principio) que
# haga una propuesta seria de cambio, pero que sepa que abriríamos la caja
# de Pandora, pues hay muchas palabras posibles para pipe: tubería,
# conducto, cañería, canal, etc.
#
# En cuanto a poner (pipe) entre paréntesis, es una mala costumbre que
# deberíamos desterrar ya. Eso se hace en los libros la primera vez, pero
# aquí no sólo no hay primera vez, sino que el mismo mensaje puede
# aparecer *varias* veces, y entonces sí que es una paliza.
# Ejemplo de paliza: "tubería rota" en libc. Sale muchísimo y no es
# cuestión de ver (pipe) cuarenta veces al día...
#: src/buffer.c:417
msgid "(pipe)"
msgstr "(tubería)"

# ¿No queda más bonita la 1ª comilla abierta así: `record_size'?
# Sí. FIXME. Comunicar al autor. sv
#: src/buffer.c:440
msgid "Invalid value for record_size"
msgstr "El valor de `record_size' no es válido"

#: src/buffer.c:443
msgid "No archive name given"
msgstr "No se ha especificado ningún nombre de archivo"

# FIXME: Si la entrada/salida estándar no es un archivo, ¿por qué el
# original se refiere a ella como tal?
#
# En cierto sentido, sí es un archivo, o se puede emplear como tal.
# Tar al menos la trata así, en `tar -f -' (o sin la opción -f en este
# GNU tar)'; luego la E/S std. puede ser un archivo "real" de disco:
# tar ... -f - > arch.tar       gerardo
#
# Esto corresponde a la opción --verify.
# Ejemplos: "tar cWf - ." y "tar xWf -"
# o sea que una traducción correcta se vería más como:
# "No se puede verificar un archivo desde/hacia la entrada/salida estándar"
# o algo así. Quizá "No se puede verificar un archivo tomado de la entrada
# estándar o escrito hacia la salida estándar", pero es un poco largo.. =)
#
#: src/buffer.c:487
msgid "Cannot verify stdin/stdout archive"
msgstr "No se puede verificar la entrada/salida estándar"

#: src/buffer.c:500
#, c-format
msgid "Archive is compressed. Use %s option"
msgstr "El archivo está comprimido. Utilice la opción %s"

#: src/buffer.c:547 src/tar.c:2131
msgid "Cannot update compressed archives"
msgstr "No se pueden actualizar archivos comprimidos"

#. TRANSLATORS: This is a ``checkpoint of write operation'',
#. *not* ``Writing a checkpoint''.
#. E.g. in Spanish ``Punto de comprobaci@'on de escritura'',
#. *not* ``Escribiendo un punto de comprobaci@'on''
#: src/buffer.c:597
#, fuzzy, c-format
msgid "Write checkpoint %u"
msgstr "Punto de comprobación de escritura %d"

#. TRANSLATORS: This is a ``checkpoint of read operation'',
#. *not* ``Reading a checkpoint''.
#. E.g. in Spanish ``Punto de comprobaci@'on de lectura'',
#. *not* ``Leyendo un punto de comprobaci@'on''
#: src/buffer.c:603
#, fuzzy, c-format
msgid "Read checkpoint %u"
msgstr "Punto de comprobación de lectura %d"

#: src/buffer.c:655
msgid "At beginning of tape, quitting now"
msgstr "Al principio de la cinta, se terminará ahora"

#: src/buffer.c:661
msgid "Too many errors, quitting"
msgstr "Demasiados errores, abandono"

#: src/buffer.c:689
#, c-format
msgid "Unaligned block (%lu byte) in archive"
msgid_plural "Unaligned block (%lu bytes) in archive"
msgstr[0] "Bloque no alineado (%lu byte) dentro del archivo"
msgstr[1] "Bloque no alineado (%lu bytes) dentro del archivo"

#: src/buffer.c:709
#, c-format
msgid "Record size = %lu block"
msgid_plural "Record size = %lu blocks"
msgstr[0] "Tamaño del registro = %lu bloque"
msgstr[1] "Tamaño del registro = %lu bloques"

#: src/buffer.c:782
msgid "Cannot backspace archive file; it may be unreadable without -i"
msgstr "No se puede ir hacia atrás en el archivo; puede ser ilegible sin -i"

#: src/buffer.c:814
msgid "rmtlseek not stopped at a record boundary"
msgstr "rmtlseek no paró en los límites de un registro"

#: src/buffer.c:870
#, c-format
msgid "%s: contains invalid volume number"
msgstr "%s: contiene un número de volumen inválido"

#: src/buffer.c:905
msgid "Volume number overflow"
msgstr "Desbordamiento en el número de volumen"

#: src/buffer.c:920
#, c-format
msgid "Prepare volume #%d for %s and hit return: "
msgstr "Prepare el volumen #%d para %s y pulse intro: "

#: src/buffer.c:926
msgid "EOF where user reply was expected"
msgstr ""
"Se encontró un final de fichero mientras se esperaba respuesta del usuario"

#: src/buffer.c:931 src/buffer.c:963
msgid "WARNING: Archive is incomplete"
msgstr "ATENCIÓN: El archivo está incompleto"

# Antes de que nadie diga nada:
# shell admite muchas traducciones, caparazón, concha, envoltorio, coraza,
# etc. pero ninguna ha prosperado. Además, algunos nombres son innombrables
# en ciertos países, así que mejor dejarlo como está.
# Y si no se traduce, se queda en *el* shell, es decir, *neutro*.
#
# Ya que volúmenes se acentúa, ¿habría que poner "volumen/volúmenes"
# en lugar de "volumen(es)"?
# No me gusta, ya que sólo es plural con la parte entre paréntesis "(y consecutivos)". fr
# Creo que esta bien así Gerardo. em+
# # Cuidadín. ¿El nombre de archivo se le da *al* volumen? Literalmente
# # dice que da un nuevo nombre *para* el sgute. volumen, pero ¿ese
# # nombre es el del volumen? No entiendo bien el contexto; quizá
# # habría que mirar el código fuente o ver cuándo sale este
# # mensaje.
# # Otra cosa es eso de "abortar". No sé si se habrá tratado en
# # spanglish o en es@li.org, pero suena muy feo, ¿no? Quizá "Sale
# # inmediatamente de tar".
#
# "Print this list" es exactamente "Imprime esta lista" o a lo sumo "Muestra
# esta lista". No veo que diga ayuda en ninguna parte, no creo que un
# traductor deba ser más inteligente que el escritor original.. =) nl
# Yo creo que a veces sí :-) sv
# Sí, un programador no tiene por qué ser buen escritor :-) En un fortune me
# salió una vez: "Los que no saben escribir, escriben manuales". :-)
# A mí aquí me da igual lista que ayuda, de las dos formas se entiende. Manda
# el traductor original. gerardo
# ¿A alguien más le parece mal que ponga ayuda en vez de lista? sv
#: src/buffer.c:945
#, fuzzy, c-format
msgid ""
" n name        Give a new file name for the next (and subsequent) volume(s)\n"
" q             Abort tar\n"
" y or newline  Continue operation\n"
msgstr ""
" n [nombre] Da un nuevo nombre de archivo al siguiente\n"
"            (y consecutivos) volumen(es)\n"
" q          Aborta tar\n"
" !          Lanza un subshell\n"
" ?          Muestra esta ayuda\n"

#: src/buffer.c:950
#, c-format
msgid " !             Spawn a subshell\n"
msgstr ""

#: src/buffer.c:951
#, c-format
msgid " ?             Print this list\n"
msgstr ""

# "saliendo"->"finalizando". jmg
# Je, je, ¿no has leído, Santiago, el `dardo' de Fdo. Lázaro Carreter sobre
# finalizar? No sé por qué quitar lo de salir, to exit es salir, no acabar.
# Uno se sale del programa, y éste acaba. En realidad, también da igual, de
# cualquier forma se entiende, pero mejor acabar o terminar que finalizar,
# total, son sinónimos. gerardo
#: src/buffer.c:958
msgid "No new volume; exiting.\n"
msgstr "No hay volumen nuevo; finalizando.\n"

#: src/buffer.c:991
msgid "File name not specified. Try again.\n"
msgstr ""

#: src/buffer.c:1004
#, c-format
msgid "Invalid input. Type ? for help.\n"
msgstr ""

#: src/buffer.c:1055
#, fuzzy, c-format
msgid "%s command failed"
msgstr "La orden `%s' falló"

#: src/buffer.c:1117 src/delete.c:210 src/list.c:169 src/update.c:165
msgid "This does not look like a tar archive"
msgstr "Esto no parece un archivo tar"

#: src/buffer.c:1211
#, fuzzy, c-format
msgid "%s is possibly continued on this volume: header contains truncated name"
msgstr "%s no continúa en este volumen"

#: src/buffer.c:1215
#, c-format
msgid "%s is not continued on this volume"
msgstr "%s no continúa en este volumen"

#: src/buffer.c:1229
#, c-format
msgid "%s is the wrong size (%s != %s + %s)"
msgstr "%s tiene un tamaño erróneo (%s != %s + %s)"

# Sugerencia: está fuera de secuencia -> no está en orden. sv
# Creo recordar que en el CPBackup de Central Point ponía lo de "fuera de
# secuencia". fr
# Buena referencia :-).
# El comentario habrá que conservarlo en la versión final. sv
# Bueno, la verdad es que ahora que lo pienso, me parece una mala
# traducción... ¿opiniones? sv
# Me parece correcta la traducción "literal", pero me gusta
# más tu sugerencia  - gerardo
# El problema es que un volumen individual no puede estar desordenado.
# Lo que está ordenado o no es la sucesión entera.
# Un volumen individual puede estar fuera de lugar, pero no desordenado
# él solito.
# Todavía espero una solución mágica que sea mejor que las dos
# que tenemos hasta ahora.
#: src/buffer.c:1239
msgid "This volume is out of sequence"
msgstr "Este volumen está fuera de secuencia"

# Ojo que esto podría referirse a "is not being labelled NOW" en vez de
# "isn't labelled". Pero no tengo los fuentes para ver la intención
# original. nl
# Si no se sabe eso, se podría dejar de forma más neutra como
# "Archivo no etiquetado para concordancia con `%s'" - gerardo (gag)
# FIXME: Preguntar.
#: src/buffer.c:1285
#, c-format
msgid "Archive not labeled to match %s"
msgstr "El archivo no está etiquetado para que coincida con %s"

#: src/buffer.c:1288
#, c-format
msgid "Volume %s does not match %s"
msgstr "El volumen %s no coincide con %s"

#: src/buffer.c:1384
#, fuzzy, c-format
msgid ""
"%s: file name too long to be stored in a GNU multivolume header, truncated"
msgstr ""
"%s: el nombre del fichero es demasiado largo para almacenarse en una "
"cabecera\n"
"multivolumen de GNU"

#: src/compare.c:96
#, c-format
msgid "Could only read %lu of %lu byte"
msgid_plural "Could only read %lu of %lu bytes"
msgstr[0] "Sólo se pudieron leer %lu de %lu byte"
msgstr[1] "Sólo se pudieron leer %lu de %lu bytes"

#: src/compare.c:106 src/compare.c:122
msgid "Contents differ"
msgstr "El contenido es distinto"

#: src/compare.c:149 src/extract.c:773 src/incremen.c:1191 src/list.c:374
#: src/list.c:1294
msgid "Unexpected EOF in archive"
msgstr "Fin de fichero inesperado en el archivo"

#: src/compare.c:197 src/compare.c:213 src/compare.c:331 src/compare.c:395
msgid "File type differs"
msgstr "El tipo de fichero es distinto"

# El autor quería un mensaje muy conciso, y en la traducción se expande a una
# oración completa.. ¿Por qué? Debería ser "Distinto modo".
# Porque el idioma inglés es más corto. Si a cada frase corta le hago
# corresponder siempre una frase corta española, el resultado sonará a indio
# completamente (me refiero a los indios esos de las películas del oeste,
# que solamente hablan con sustantivos, verbos y adjetivos). sv
#: src/compare.c:200 src/compare.c:220 src/compare.c:345
msgid "Mode differs"
msgstr "El modo es distinto"

#: src/compare.c:223
msgid "Uid differs"
msgstr "El uid es distinto"

#: src/compare.c:225
msgid "Gid differs"
msgstr "El gid es distinto"

#: src/compare.c:229
msgid "Mod time differs"
msgstr "La fecha de modificación es distinta"

#: src/compare.c:233 src/compare.c:403
msgid "Size differs"
msgstr "El tamaño es distinto"

# Creo que este enlace se efectúa al descomprimir un archivo tar.
# No es que nos diga si está enlazado o no lo está, sino si él hace
# el enlace o no lo hace. sv
#: src/compare.c:287
#, c-format
msgid "Not linked to %s"
msgstr "No se enlaza a %s"

#: src/compare.c:310
msgid "Symlink differs"
msgstr "El enlace simbólico es distinto"

#: src/compare.c:339
msgid "Device number differs"
msgstr "El número de dispositivo es distinto"

# "Verifica ". Supongo que depende de si se concatena en algún
# mensaje. jmg
# FUZZY. Es verdad, habrá que verlo.
#: src/compare.c:445
#, c-format
msgid "Verify "
msgstr "Verificar "

# # ¿Quizá diffed es el participio de diff, siendo esto un verbo tomado
# # del nombre del programa diff? Entonces querría decir que se ha
# # efectuado un diff como si el *fichero* hubiera sido normal. Yo sólo
# # cambiaría "se toma" por "se ha tomado". gag
# Es norma habitual convertir un pasado en un presente en estos casos.
# Realmente, dice lo que hace y no lo que ha hecho. sv
# FIXME. Decirle al autor que estandarice las comillas: ¿'%c' o `%c'?
# De momento lo estandarizo en la traducción.
#: src/compare.c:452
#, fuzzy, c-format
msgid "%s: Unknown file type `%c', diffed as normal file"
msgstr ""
"%s: Tipo de fichero `%c' desconocido, se toma la diferencia\n"
"como fichero normal"

#: src/compare.c:508
msgid "Archive contains file names with leading prefixes removed."
msgstr ""
"El archivo contiene nombres de fichero con los prefijos iniciales eliminados."

#: src/compare.c:510
msgid "Verification may fail to locate original files."
msgstr "Puede que la verificación no encuentre los ficheros originales."

#: src/compare.c:580
#, c-format
msgid "VERIFY FAILURE: %d invalid header detected"
msgid_plural "VERIFY FAILURE: %d invalid headers detected"
msgstr[0] "FALLO DE VERIFICACIÓN: %d cabecera inválida detectada"
msgstr[1] "FALLO DE VERIFICACIÓN: %d cabeceras inválidas detectadas"

#: src/create.c:167
#, c-format
msgid "value %s out of %s range %s..%s; substituting %s"
msgstr "valor %s fuera del rango %s %s..%s; se sustituye %s"

#: src/create.c:173
#, c-format
msgid "value %s out of %s range %s..%s"
msgstr "valor %s fuera del rango %s %s..%s"

#: src/create.c:233
msgid "Generating negative octal headers"
msgstr "Generando cabeceras octales negativas"

#: src/create.c:519 src/create.c:582
#, c-format
msgid "%s: file name is too long (max %d); not dumped"
msgstr "%s: el nombre del fichero es demasiado largo (máx %d); no se vuelca"

#: src/create.c:529
#, c-format
msgid "%s: file name is too long (cannot be split); not dumped"
msgstr ""
"%s: el nombre del fichero es demasiado largo (no se puede dividir); no se "
"vuelca"

#: src/create.c:556
#, c-format
msgid "%s: link name is too long; not dumped"
msgstr "%s: el nombre del enlace es demasiado largo; no se vuelca"

# "se rellena" debería ser "rellenando". "se rellena" puede entenderse como
# varias cosas, no queda claro que es lo que se esta haciendo, podría indicar
# lo que se suele hacer.. =)   "rellenando con ceros" es perfecto y es
# exactamente lo que está escrito en el original. sv
#
# Que sí, reconozco que la traducción es un poco libre.
# Pero mi intención es que el programa diga lo que va haciendo, no lo que ya
# ha hecho. Ni siquiera el original es consistente en los modos verbales. sv
#: src/create.c:972
#, c-format
msgid "%s: File shrank by %s byte; padding with zeros"
msgid_plural "%s: File shrank by %s bytes; padding with zeros"
msgstr[0] ""
"%s: El tamaño del fichero ha disminuido en %s byte, se rellena con ceros"
msgstr[1] ""
"%s: El tamaño del fichero ha disminuido en %s bytes, se rellena con ceros"

#: src/create.c:1112
#, c-format
msgid "%s: file is on a different filesystem; not dumped"
msgstr "%s: el fichero está en un sistema de ficheros distinto; no se vuelca"

#: src/create.c:1122
#, c-format
msgid "%s: contains a cache directory tag; not dumped"
msgstr "%s: contiene una marca de directorio caché; no se vuelca"

# ignore no es ignorar, es "no hacer caso"
# se puede usar: no tener en cuenta, descartar, no tener efecto,
# pasar por alto,
# ignorar es "not to know". sv
# ¿Y cuando se ignora a una persona ;-)? fr
# Lo mismo: Está mal dicho, se dice que no le haces caso a esa persona.
# Si no me crees busca "ignore" en algún buen diccionario.
# O mira la lista de pifias de Ángel Álvarez directamente.
# La tengo en ftp.unex.es.
# Lo siento, Santiago, hemos sido derrotados; "ignorar" ya viene en los
# diccionarios de español, y creo que hasta en el DRAE, con el significado
# que tiene en inglés "to ignore"; aunque nosotros podemos ignorarlo ;-)
# y seguir en la ortodoxia castellana :-) gerardo
# Seguiremos en la ortodoxia, pero aún así, no puedo creerme que venga
# en el DRAE. ¿Estás seguro? sv
# No, no me compré el DRAE. Pregúntalo a spanglish (si te atreves ;-) gerardo
#: src/create.c:1280
#, c-format
msgid "%s: Unknown file type; file ignored"
msgstr "%s: Tipo de fichero desconocido; no se tendrá en cuenta"

#: src/create.c:1381
#, fuzzy, c-format
msgid "Missing links to %s.\n"
msgstr "Faltan enlaces a '%s'.\n"

#: src/create.c:1452
#, c-format
msgid "%s: file is unchanged; not dumped"
msgstr "%s: el fichero no ha cambiado; no se vuelca"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/create.c:1460
#, c-format
msgid "%s: file is the archive; not dumped"
msgstr "%s: el fichero es el propio archivo; no se vuelca"

#: src/create.c:1490
#, c-format
msgid "%s: File removed before we read it"
msgstr "%s: El fichero fue borrado antes de leerlo"

#: src/create.c:1562
#, c-format
msgid "%s: file changed as we read it"
msgstr "%s: el fichero cambió mientras se estaba leyendo"

#: src/create.c:1641
#, c-format
msgid "%s: socket ignored"
msgstr "%s: el `socket' no se tendrá en cuenta"

#: src/create.c:1646
#, c-format
msgid "%s: door ignored"
msgstr "%s: no se tendrá en cuenta la puerta"

#: src/delete.c:216 src/list.c:183 src/update.c:170
msgid "Skipping to next header"
msgstr "Saltando a la siguiente cabecera"

#: src/delete.c:281
msgid "Deleting non-header from archive"
msgstr "Borrando no-cabecera del archivo"

#: src/extract.c:194
#, c-format
msgid "%s: implausibly old time stamp %s"
msgstr "%s: marca de fecha sospechosamente antigua %s"

#: src/extract.c:211
#, fuzzy, c-format
msgid "%s: time stamp %s is %s s in the future"
msgstr "%s: la marca de tiempo %s está %lu s en el futuro"

#: src/extract.c:383
#, c-format
msgid "%s: Unexpected inconsistency when making directory"
msgstr "%s: Inconsistencia inesperada al crear el directorio"

#: src/extract.c:576
#, c-format
msgid "%s: Directory renamed before its status could be extracted"
msgstr ""
"%s: El directorio fue renombrado antes de que se pudiera extraer su estado"

# Nota: En Unix, se llama fichero *regular* al que no es ni un directorio,
# ni un dispositivo (de bloques o de caracteres) ni un fifo, etc.
# Uno puede pensar que son los ficheros "normales", pero eso depende,
# pues un directorio es de lo más "normal"...
#: src/extract.c:711
msgid "Extracting contiguous files as regular files"
msgstr "Extrayendo ficheros contiguos como ficheros regulares"

# ¿Enlaces fuertes? Aquí los profes. de Sistemas Operativos y otros
# dicen "enlaces duros", y creo que los libros también lo ponen así. gag
# Es una cuestión todavía no dirimida.
# ¿Tienes algún dato más? ¿Qué dicen los libros? sv
# Enlaces duros. Lo acabo de mirar en un libro. gag
#: src/extract.c:979
msgid "Attempting extraction of symbolic links as hard links"
msgstr "Intentando la extracción de enlaces simbólicos como enlaces duros"

#: src/extract.c:1037
#, c-format
msgid "Reading %s\n"
msgstr "Leyendo %s\n"

#: src/extract.c:1130
#, c-format
msgid "%s: Cannot extract -- file is continued from another volume"
msgstr "%s: No se puede extraer -- el fichero es continuación de otro volumen"

# ¿No se referirá al autor a "mangled filenames"?... jmg
# FIXME. Preguntárselo.
#: src/extract.c:1137 src/list.c:1057
#, fuzzy
msgid "Unexpected long name header"
msgstr "Fin de fichero inesperado en los nombres modificados"

# FIXME. Lo de las comillas '%c'.
# Como antes, lo estandarizo en la traducción a pesar de todo.
#: src/extract.c:1143
#, fuzzy, c-format
msgid "%s: Unknown file type `%c', extracted as normal file"
msgstr "%s: Tipo de fichero `%c' desconocido, se extrae como fichero normal"

#: src/extract.c:1168
#, fuzzy, c-format
msgid "Current %s is newer or same age"
msgstr "El `%s' actual es más reciente"

#: src/extract.c:1214
#, c-format
msgid "%s: Was unable to backup this file"
msgstr "%s: No se pudo hacer copia de seguridad de este fichero"

#: src/extract.c:1342
#, fuzzy, c-format
msgid "Cannot rename %s to %s"
msgstr "%s: No se puede renombrar a %s"

#: src/extract.c:1354
#, c-format
msgid "Error is not recoverable: exiting now"
msgstr "El error no es recuperable: salida ahora"

#: src/incremen.c:260 src/incremen.c:300
#, fuzzy, c-format
msgid "%s: Directory has been renamed from %s"
msgstr "%s: El directorio ha sido renombrado"

#: src/incremen.c:270
#, c-format
msgid "%s: Directory has been renamed"
msgstr "%s: El directorio ha sido renombrado"

#: src/incremen.c:311
#, c-format
msgid "%s: Directory is new"
msgstr "%s: El directorio es nuevo"

#: src/incremen.c:697 src/incremen.c:714
msgid "Invalid time stamp"
msgstr "Marca de tiempo inválida"

#: src/incremen.c:753
#, fuzzy
msgid "Invalid modification time (seconds)"
msgstr "Se ha especificado un modo no válido en la opción"

#: src/incremen.c:768
msgid "Invalid modification time (nanoseconds)"
msgstr ""

#: src/incremen.c:788
msgid "Invalid device number"
msgstr "Número de dispositivo inválido"

#: src/incremen.c:803
msgid "Invalid inode number"
msgstr "Número de nodo-i inválido"

#: src/incremen.c:854 src/incremen.c:891
msgid "Field too long while reading snapshot file"
msgstr ""

#: src/incremen.c:861 src/incremen.c:899
#, fuzzy
msgid "Read error in snapshot file"
msgstr "Error de lectura en %s"

#: src/incremen.c:863 src/incremen.c:903 src/incremen.c:955
#: src/incremen.c:1013
#, fuzzy
msgid "Unexpected EOF in snapshot file"
msgstr "Fin de fichero inesperado en el archivo"

#: src/incremen.c:870 src/incremen.c:910
msgid "Unexpected field value in snapshot file"
msgstr ""

#: src/incremen.c:1005
msgid "Missing record terminator"
msgstr ""

#: src/incremen.c:1056 src/incremen.c:1059
msgid "Bad incremental file format"
msgstr ""

#: src/incremen.c:1078
#, c-format
msgid "Unsupported incremental format version: %<PRIuMAX>"
msgstr ""

#: src/incremen.c:1231
#, c-format
msgid "Malformed dumpdir: expected '%c' but found %#3o"
msgstr ""

#: src/incremen.c:1241
msgid "Malformed dumpdir: 'X' duplicated"
msgstr ""

#: src/incremen.c:1254
#, fuzzy
msgid "Malformed dumpdir: empty name in 'R'"
msgstr "Argumento de densidad mal formado: '%s'"

#: src/incremen.c:1267
msgid "Malformed dumpdir: 'T' not preceeded by 'R'"
msgstr ""

#: src/incremen.c:1273
#, fuzzy
msgid "Malformed dumpdir: empty name in 'T'"
msgstr "Argumento de densidad mal formado: '%s'"

#: src/incremen.c:1293
#, c-format
msgid "Malformed dumpdir: expected '%c' but found end of data"
msgstr ""

#: src/incremen.c:1299
msgid "Malformed dumpdir: 'X' never used"
msgstr ""

#: src/incremen.c:1342
#, c-format
msgid "Cannot create temporary directory using template %s"
msgstr ""

#: src/incremen.c:1390
#, c-format
msgid "%s: Not purging directory: unable to stat"
msgstr "%s: No se purga el directorio: no se puede efectuar `stat'"

#: src/incremen.c:1403
#, c-format
msgid "%s: directory is on a different device: not purging"
msgstr "%s: el directorio está en un dispositivo distinto: no se purga"

#: src/incremen.c:1411
#, c-format
msgid "%s: Deleting %s\n"
msgstr "%s: Borrando %s\n"

#: src/incremen.c:1416
#, c-format
msgid "%s: Cannot remove"
msgstr "%s: No se puede borrar"

#: src/list.c:115
#, c-format
msgid "%s: Omitting"
msgstr "%s: Se omite"

#: src/list.c:133
#, c-format
msgid "block %s: ** Block of NULs **\n"
msgstr "bloque %s: ** Bloque de NULos **\n"

#: src/list.c:146
#, c-format
msgid "A lone zero block at %s"
msgstr "Un bloque de ceros aislado en %s"

#: src/list.c:157
#, c-format
msgid "block %s: ** End of File **\n"
msgstr "bloque %s: ** Fin de Fichero **\n"

#: src/list.c:180 src/list.c:1026 src/list.c:1262
#, c-format
msgid "block %s: "
msgstr "bloque %s: "

#. TRANSLATORS: %s is type of the value (gid_t, uid_t, etc.)
#: src/list.c:634
#, c-format
msgid "Blanks in header where numeric %s value expected"
msgstr "Hay blancos en la cabecera cuando se esperaba el valor numérico %s"

#. TRANSLATORS: Second %s is a type name (gid_t,uid_t,etc.)
#: src/list.c:689
#, c-format
msgid "Archive octal value %.*s is out of %s range; assuming two's complement"
msgstr ""
"El valor octal %.*s del archivo está fuera del rango %s;\n"
"se supone complemento a dos"

#. TRANSLATORS: Second %s is a type name (gid_t,uid_t,etc.)
#: src/list.c:700
#, c-format
msgid "Archive octal value %.*s is out of %s range"
msgstr "El valor octal %.*s del archivo está fuera del rango %s"

#: src/list.c:721
msgid "Archive contains obsolescent base-64 headers"
msgstr "El archivo contiene cabeceras base 64 obsoletas"

#: src/list.c:735
#, c-format
msgid "Archive signed base-64 string %s is out of %s range"
msgstr "La cadena firmada en base 64 %s del archivo está fuera del rango %s"

#: src/list.c:766
#, c-format
msgid "Archive base-256 value is out of %s range"
msgstr "El valor en base 256 del archivo está fuera del rango %s"

#. TRANSLATORS: Second %s is a type name (gid_t,uid_t,etc.)
#: src/list.c:795
#, c-format
msgid "Archive contains %.*s where numeric %s value expected"
msgstr "El archivo contiene %.*s donde se esperaba el valor numérico %s"

#. TRANSLATORS: Second %s is type name (gid_t,uid_t,etc.)
#: src/list.c:817
#, fuzzy, c-format
msgid "Archive value %s is out of %s range %s..%s"
msgstr "El valor del archivo %s está fuera del rango %s %s.%s"

#: src/list.c:1193
#, c-format
msgid " link to %s\n"
msgstr " enlace a %s\n"

#: src/list.c:1201
#, c-format
msgid " unknown file type %s\n"
msgstr " tipo de fichero desconocido %s\n"

#: src/list.c:1219
#, c-format
msgid "--Long Link--\n"
msgstr "--Enlace largo--\n"

#: src/list.c:1223
#, c-format
msgid "--Long Name--\n"
msgstr "--Nombre largo--\n"

#: src/list.c:1227
#, c-format
msgid "--Volume Header--\n"
msgstr "--Cabecera de Volumen--\n"

#: src/list.c:1235
#, c-format
msgid "--Continued at byte %s--\n"
msgstr "--Continúa en el byte %s--\n"

#: src/list.c:1239
#, c-format
msgid "--Mangled file names--\n"
msgstr "--Nombres de fichero modificados--\n"

#: src/list.c:1267
msgid "Creating directory:"
msgstr "Creando el directorio:"

# ¿No se referirá al autor a "mangled filenames"?... jmg
# FIXME. Preguntárselo.
#: src/mangle.c:54
msgid "Unexpected EOF in mangled names"
msgstr "Fin de fichero inesperado en los nombres modificados"

#: src/mangle.c:90 src/misc.c:467 src/misc.c:485
#, c-format
msgid "%s: Cannot rename to %s"
msgstr "%s: No se puede renombrar a %s"

#: src/mangle.c:93
#, c-format
msgid "Renamed %s to %s"
msgstr "Se renombra %s como %s"

#: src/mangle.c:110
#, c-format
msgid "%s: Cannot symlink to %s"
msgstr "%s: No se puede crear un enlace simbólico a %s"

#: src/mangle.c:113
#, c-format
msgid "Symlinked %s to %s"
msgstr "Se enlaza %s simbólicamente a %s"

# ¿desmutilador? sv. (Perdona mi ignorancia: ¿qué significa?)
# No lo sé, tengo que consultar. Lo encontré en un diccionario raro. fr
# Bueno, yo tampoco sé lo que es, pero "mangling" me suena a:
# "proceso mediante el cual se codifican ciertos nombres de cierta manera."
# Por ejemplo, "name mangling" es lo que hace Linux cuando se instala
# con umsdos. (¿Lo has visto alguna vez?).
# También se habla de "mangling" a la forma que tiene el C++ de incluir
# los nombres de las funciones (o de las clases quizá) en un archivo
# objeto ( .o ).
# Bueno, en realidad no lo sé, pero espero haberte dado alguna idea.
# A ver qué dice Enrique u otro revisor. sv
# Sigo en blanco. fr
# La traducción mas acertada creo que es esta :) , el uso que conozco
# de mangled esta relacionado con codificar o transformar el nombre de una
# función C++ dentro de una biblioteca, de manera que se pueda deshacer la
# referencia a la función al compilar o enlazar dinámicamente, obteniendo
# la función que corresponde al aplicar la sobrecarga de operadores. em+
# # Todo eso es así, lo malo es encontrar la palabra simple más
# # adecuada y  mantenerla. Por ejemplo, antes hemos dicho "mutilar", en
# # otros mensajes; y ahora "desenredar".
#: src/mangle.c:117
#, c-format
msgid "Unknown demangling command %s"
msgstr "Orden desconocida para recuperar el nombre original de %s"

#: src/misc.c:458
#, c-format
msgid "Renaming %s to %s\n"
msgstr "Se renombra %s como %s\n"

#: src/misc.c:490
#, c-format
msgid "Renaming %s back to %s\n"
msgstr "Se vuelve a renombrar %s como %s\n"

#: src/misc.c:632
msgid "Cannot save working directory"
msgstr "No se puede guardar el directorio de trabajo"

#: src/misc.c:638
msgid "Cannot change working directory"
msgstr "No se puede cambiar el directorio de trabajo"

#: src/misc.c:728
msgid "child process"
msgstr "proceso hijo"

#: src/misc.c:737
msgid "interprocess channel"
msgstr "canal de interproceso"

#. TRANSLATORS: The following three msgids form a single sentence.
#.
#: src/names.c:600
msgid "Pattern matching characters used in file names. Please,"
msgstr ""

#: src/names.c:602
msgid "use --wildcards to enable pattern matching, or --no-wildcards to"
msgstr ""

#: src/names.c:604
msgid "suppress this warning."
msgstr ""

#: src/names.c:619 src/names.c:637
#, c-format
msgid "%s: Not found in archive"
msgstr "%s: No se encuentra en el archivo"

#: src/names.c:622
#, c-format
msgid "%s: Required occurrence not found in archive"
msgstr "%s: El elemento solicitado no se encuentra en el archivo"

#: src/tar.c:79
#, c-format
msgid "Options `-%s' and `-%s' both want standard input"
msgstr "Las opciones `-%s' y `-%s' requieren entrada estándar"

#: src/tar.c:156
#, c-format
msgid "%s: Invalid archive format"
msgstr "%s: Formato de archivo inválido"

#: src/tar.c:180
msgid "GNU features wanted on incompatible archive format"
msgstr "Se requieren características de GNU en formato de archivo incompatible"

#: src/tar.c:241
#, c-format
msgid ""
"Unknown quoting style `%s'. Try `%s --quoting-style=help' to get a list."
msgstr ""

# Yo usaría "recuperar", en vez de "restablecer". Lo de repetir "archivo"
# dos veces en la misma frase no me suena bien, así que pondría "... a
# partir de aquél". jmg
# El original también repite. sv
#
# ¡CUIDADO! sólo no debe llevar tilde en ".. juntos en un solo archivo..."
# `Solo' sólo lleva acento cuando equivale al adverbio de modo `solamente',
# y aun así no es obligatorio ponérselo si no hay ambigüedad (lo siento,
# muchachos, pero saqué sobresaliente en Lingüística de COU :-D ) gerardo
# Lo cambio, pero "no es obligatorio" no es lo mismo que "está mal". sv
#
# # la versión de control -> el control de versión
# # nil: numeradas... simples... (en plural)
# # never, simPle (falta una pe): backup -> copia de seguridad. gag
# Estoy de acuerdo con lo de gag (más arriba usas eso mismo). jmg
#: src/tar.c:323
#, fuzzy
msgid ""
"GNU `tar' saves many files together into a single tape or disk archive, and "
"can restore individual files from the archive.\n"
"\n"
"Examples:\n"
"  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.\n"
"  tar -tvf archive.tar         # List all files in archive.tar verbosely.\n"
"  tar -xf archive.tar          # Extract all files from archive.tar.\n"
msgstr ""
"GNU `tar' guarda varios ficheros juntos en un solo archivo en cinta o disco, "
"y\n"
"puede restablecer ficheros individuales a partir del archivo.\n"
"\n"
"Ejemplos:\n"
"  tar -cf archivo.tar fu fa # Crea archivo.tar con los ficheros fu y fa.\n"
"  tar -tvf archivo.tar      # Lista los ficheros de archivo.tar con "
"detalle.\n"
"  tar -xf archivo.tar       # Extrae todos los ficheros de archivo.tar.\n"
"\vEl sufijo de respaldo es `~', a menos que se especifique con --suffix\n"
"o con SIMPLE_BACKUP_SUFFIX. El control de versiones puede establecerse\n"
"con --backup o con VERSION_CONTROL, los valores son:\n"
"\n"
"  t, numbered     hace copias de seguridad numeradas\n"
"  nil, existing   numerada si existen copias de seguridad numeradas, "
"simples\n"
"                  en otro caso\n"
"  never, simple   siempre hace copias de seguridad simples\n"

# Yo usaría "recuperar", en vez de "restablecer". Lo de repetir "archivo"
# dos veces en la misma frase no me suena bien, así que pondría "... a
# partir de aquél". jmg
# El original también repite. sv
#
# ¡CUIDADO! sólo no debe llevar tilde en ".. juntos en un solo archivo..."
# `Solo' sólo lleva acento cuando equivale al adverbio de modo `solamente',
# y aun así no es obligatorio ponérselo si no hay ambigüedad (lo siento,
# muchachos, pero saqué sobresaliente en Lingüística de COU :-D ) gerardo
# Lo cambio, pero "no es obligatorio" no es lo mismo que "está mal". sv
#
# # la versión de control -> el control de versión
# # nil: numeradas... simples... (en plural)
# # never, simPle (falta una pe): backup -> copia de seguridad. gag
# Estoy de acuerdo con lo de gag (más arriba usas eso mismo). jmg
#: src/tar.c:332
#, fuzzy
msgid ""
"The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control may be set with --backup or VERSION_CONTROL, values "
"are:\n"
"\n"
"  none, off       never make backups\n"
"  t, numbered     make numbered backups\n"
"  nil, existing   numbered if numbered backups exist, simple otherwise\n"
"  never, simple   always make simple backups\n"
msgstr ""
"GNU `tar' guarda varios ficheros juntos en un solo archivo en cinta o disco, "
"y\n"
"puede restablecer ficheros individuales a partir del archivo.\n"
"\n"
"Ejemplos:\n"
"  tar -cf archivo.tar fu fa # Crea archivo.tar con los ficheros fu y fa.\n"
"  tar -tvf archivo.tar      # Lista los ficheros de archivo.tar con "
"detalle.\n"
"  tar -xf archivo.tar       # Extrae todos los ficheros de archivo.tar.\n"
"\vEl sufijo de respaldo es `~', a menos que se especifique con --suffix\n"
"o con SIMPLE_BACKUP_SUFFIX. El control de versiones puede establecerse\n"
"con --backup o con VERSION_CONTROL, los valores son:\n"
"\n"
"  t, numbered     hace copias de seguridad numeradas\n"
"  nil, existing   numerada si existen copias de seguridad numeradas, "
"simples\n"
"                  en otro caso\n"
"  never, simple   siempre hace copias de seguridad simples\n"

#: src/tar.c:358
msgid "Main operation mode:"
msgstr "Modo principal de operación:"

#: src/tar.c:361
msgid "list the contents of an archive"
msgstr "lista el contenido de un archivo"

#: src/tar.c:363
msgid "extract files from an archive"
msgstr "extrae ficheros de un archivo"

#: src/tar.c:366
msgid "create a new archive"
msgstr "crea un nuevo archivo"

#: src/tar.c:368
msgid "find differences between archive and file system"
msgstr "encuentra las diferencias entre un archivo y el sistema de ficheros"

#: src/tar.c:371
msgid "append files to the end of an archive"
msgstr "añade ficheros al final de un archivo"

#: src/tar.c:373
msgid "only append files newer than copy in archive"
msgstr "solamente añade ficheros más recientes que la copia del archivo"

#: src/tar.c:375
msgid "append tar files to an archive"
msgstr "añade ficheros tar a un archivo"

#: src/tar.c:378
msgid "delete from the archive (not on mag tapes!)"
msgstr "borra del archivo (¡no en cintas magnéticas!)"

#: src/tar.c:380
msgid "test the archive volume label and exit"
msgstr ""

#: src/tar.c:385
msgid "Operation modifiers:"
msgstr "Modificadores de operación:"

#: src/tar.c:388
msgid "handle sparse files efficiently"
msgstr "maneja ficheros dispersos de forma eficiente"

#: src/tar.c:389
msgid "MAJOR[.MINOR]"
msgstr ""

#: src/tar.c:390
msgid "set version of the sparse format to use (implies --sparse)"
msgstr ""

#: src/tar.c:392
msgid "handle old GNU-format incremental backup"
msgstr "maneja el formato GNU antiguo de respaldo incremental"

#: src/tar.c:393 src/tar.c:524 src/tar.c:588 src/tar.c:592 src/tar.c:602
#: src/tar.c:679 tests/genfile.c:128 tests/genfile.c:173 tests/genfile.c:177
#: tests/genfile.c:180
msgid "FILE"
msgstr "FICHERO"

#: src/tar.c:394
msgid "handle new GNU-format incremental backup"
msgstr "maneja el nuevo formato GNU de respaldo incremental"

# ¿archivos nonzero? sv
# Estupendo Gerardo, se me había pasado, como tantas cosas em+
# # ¡Nooorl! Quiere decir que el programa tar no acaba o sale (exit())
# # devolviendo al sistema un "status" distinto de cero cuando
# # encuentre ficheros ilegibles. (¡Uf! Ahora a ver cómo se pone esto en
# # media línea.) gag
#
#: src/tar.c:396
msgid "do not exit with nonzero on unreadable files"
msgstr "no sale con estado distinto de cero cuando hay ficheros ilegibles"

#: src/tar.c:397 src/tar.c:519 src/tar.c:534 src/tar.c:632 tests/genfile.c:159
msgid "NUMBER"
msgstr "NÚMERO"

#: src/tar.c:398
#, fuzzy
msgid ""
"process only the NUMBERth occurrence of each file in the archive; this "
"option is valid only in conjunction with one of the subcommands --delete, --"
"diff, --extract or --list and when a list of files is given either on the "
"command line or via the -T option; NUMBER defaults to 1"
msgstr ""
"procesa únicamente la NUM-ésima aparición de cada fichero en el archivo. "
"Esta opción solamente es válida junto con una de las subórdenes --delete, --"
"diff, --extract o --list y cuando se da una lista de ficheros en la línea de "
"órdenes o con la opción -T. El valor predeterminado de NUM es 1."

# Mejor eso que inventarse un palabro, digo yo. sv
#: src/tar.c:404
#, fuzzy
msgid "archive is seekable"
msgstr "El archivo admite `seek'"

#: src/tar.c:409
msgid "Overwrite control:"
msgstr ""

#: src/tar.c:412
msgid "attempt to verify the archive after writing it"
msgstr "intenta verificar el archivo después de escribirlo"

#: src/tar.c:414
msgid "remove files after adding them to the archive"
msgstr "borra los ficheros después de añadirlos al archivo"

#: src/tar.c:416
msgid "don't replace existing files when extracting"
msgstr "no reemplaza ficheros que existan al extraer"

#: src/tar.c:418
msgid "don't replace existing files that are newer than their archive copies"
msgstr ""
"no reemplaza los ficheros que existan que sean más recientes que sus copias "
"en el archivo"

#: src/tar.c:420
msgid "overwrite existing files when extracting"
msgstr "sobreescribe los ficheros que existan al extraer"

#: src/tar.c:422
msgid "remove each file prior to extracting over it"
msgstr "borra cada fichero antes de extraer sobre él"

#: src/tar.c:424
msgid "empty hierarchies prior to extracting directory"
msgstr "vacía jerarquías antes de extraer directorios"

#: src/tar.c:426
msgid "preserve metadata of existing directories"
msgstr "conserva los metadatos de los directorios que existan"

#: src/tar.c:428
#, fuzzy
msgid "overwrite metadata of existing directories when extracting (default)"
msgstr "sobreescribe los ficheros que existan al extraer"

#: src/tar.c:434
msgid "Select output stream:"
msgstr ""

#: src/tar.c:437
msgid "extract files to standard output"
msgstr "extrae los ficheros a la salida estándar"

#: src/tar.c:438 src/tar.c:497 src/tar.c:499 tests/genfile.c:156
#: tests/genfile.c:183
msgid "COMMAND"
msgstr "ORDEN"

#: src/tar.c:439
#, fuzzy
msgid "pipe extracted files to another program"
msgstr "extrae los ficheros a la salida estándar"

#: src/tar.c:441
msgid "ignore exit codes of children"
msgstr ""

#: src/tar.c:443
msgid "treat non-zero exit codes of children as error"
msgstr ""

#: src/tar.c:448
msgid "Handling of file attributes:"
msgstr "Manejo de los atributos del fichero:"

#: src/tar.c:451
msgid "force NAME as owner for added files"
msgstr "fuerza NOMBRE como propietario de los ficheros que se añaden"

#: src/tar.c:453
msgid "force NAME as group for added files"
msgstr "fuerza NOMBRE como grupo para los ficheros que se añaden"

#: src/tar.c:454 src/tar.c:618
msgid "DATE-OR-FILE"
msgstr "FECHA-O-FICHERO"

#: src/tar.c:455
#, fuzzy
msgid "set mtime for added files from DATE-OR-FILE"
msgstr "almacena solamente ficheros más recientes que FECHA-O-FICHERO"

#: src/tar.c:456
msgid "CHANGES"
msgstr "CAMBIOS"

#: src/tar.c:457
msgid "force (symbolic) mode CHANGES for added files"
msgstr "fuerza CAMBIOS (simbólicos) de modo para los ficheros que se añaden"

#: src/tar.c:459
msgid "METHOD"
msgstr ""

#: src/tar.c:460
msgid ""
"preserve access times on dumped files, either by restoring the times after "
"reading (METHOD='replace'; default) or by not setting the times in the first "
"place (METHOD='system')"
msgstr ""

#: src/tar.c:464
msgid "don't extract file modified time"
msgstr "no extrae la fecha de modificación del fichero"

#: src/tar.c:466
msgid "try extracting files with the same ownership"
msgstr "intenta extraer los ficheros con el mismo propietario"

#: src/tar.c:468
msgid "extract files as yourself"
msgstr "extrae los ficheros como usted mismo"

#: src/tar.c:470
msgid "always use numbers for user/group names"
msgstr "utiliza siempre números para los nombres de usuarios/grupos"

#: src/tar.c:472
msgid "extract information about file permissions (default for superuser)"
msgstr ""

#: src/tar.c:476
msgid ""
"apply the user's umask when extracting permissions from the archive (default "
"for ordinary users)"
msgstr ""

#: src/tar.c:478
msgid "sort names to extract to match archive"
msgstr "ordena los nombres que se extraen para que coincidan con el archivo"

#: src/tar.c:481
msgid "same as both -p and -s"
msgstr "lo mismo que -p y -s"

#: src/tar.c:483
msgid ""
"delay setting modification times and permissions of extracted directories "
"until the end of extraction"
msgstr ""

#: src/tar.c:486
msgid "cancel the effect of --delay-directory-restore option"
msgstr ""

#: src/tar.c:491
#, fuzzy
msgid "Device selection and switching:"
msgstr "Selección de dispositivo y opciones:"

#: src/tar.c:493
msgid "ARCHIVE"
msgstr "ARCHIVO"

#: src/tar.c:494
msgid "use archive file or device ARCHIVE"
msgstr "utiliza un archivo o el dispositivo ARCHIVO"

#: src/tar.c:496
#, fuzzy
msgid "archive file is local even if it has a colon"
msgstr "el archivo es local incluso si tiene dos puntos"

#: src/tar.c:498
msgid "use given rmt COMMAND instead of rmt"
msgstr "utiliza la ORDEN rmt dada en vez de rmt"

#: src/tar.c:500
msgid "use remote COMMAND instead of rsh"
msgstr "utiliza la ORDEN remota en vez de rsh"

#: src/tar.c:504
msgid "specify drive and density"
msgstr "especifica la unidad y la densidad"

#: src/tar.c:518
msgid "create/list/extract multi-volume archive"
msgstr "crea/lista/extrae un archivo multivolumen"

# Una chorradita, si se me permite; estamos usando ISO-8859-1,
# ¿verdad? Y en ISO-Latin1 existe un carácter que representa la
# multiplicación, ¿verdad? Ya saben , el aspa: '×' ('\327'). Pues
# ¿por qué no usarlo (está bien, "utilizarlo" ;-) en vez de la equis
# en NUM x 1024 -> NUM × 1024?
# En otra parte dices que pones (C) en vez de © porque © no se ve bien en
# la consola. Pues no dirás eso del aspa, que se ve mejor aún que la equis:
# x × - gerardo
# Efectivamente, pero no es transportable, el que use tar bajo DJGPP
# le saldría un churro pues el aspa no existe en la tabla 850. sv
#: src/tar.c:520
msgid "change tape after writing NUMBER x 1024 bytes"
msgstr "cambia la cinta después de escribir NÚMERO x 1024 bytes"

#: src/tar.c:522
msgid "run script at end of each tape (implies -M)"
msgstr "ejecuta un script al final de cada cinta (implica -M)"

#: src/tar.c:525
msgid "use/update the volume number in FILE"
msgstr "usa/actualiza el número de volumen en FICHERO"

#: src/tar.c:530
msgid "Device blocking:"
msgstr "Bloques en los dispositivos:"

#: src/tar.c:532
msgid "BLOCKS"
msgstr "BLOQUES"

# Sigo en mis 13 y en esto no hay quien me baje del burro: BLOQUES x 512 bytes
# debe ser BLOQUES × 512 bytes. gerardo
#: src/tar.c:533
msgid "BLOCKS x 512 bytes per record"
msgstr "BLOQUES x 512 bytes por registro"

#: src/tar.c:535
#, fuzzy
msgid "NUMBER of bytes per record, multiple of 512"
msgstr "TAMAÑO bytes por registro, múltiplo de 512"

#: src/tar.c:537
msgid "ignore zeroed blocks in archive (means EOF)"
msgstr ""
"no tiene en cuenta los bloques convertidos en ceros dentro de un archivo "
"(significa fin de fichero)"

# ¿rebloquea? ¿existe esa palabra? sv
# Que opine el pueblo, no lo sé. fr
# # ¿Existe bloquear? Pues si es así, también existe rebloquear =
# # volver a bloquear. Y requetebloquear, etc. En un artículo de Martin
# # Gardner se preguntaba cuál era la palabra española más larga, y la
# # respuesta era que cualquiera que pudiera ir precedida por
# # requetequetequete... (longitud infinita). Pelín ssagerao, ¿no? gag
#
# Bueno, al final he puesto lo que se ve, un poco menos raro que rebloquear. sv
#: src/tar.c:539
msgid "reblock as we read (for 4.2BSD pipes)"
msgstr "rehace los bloques conforme se lee (para tuberías de 4.2BSD)"

# ¿Qué será esto? ¿Quizás un fallo en el mensaje original? Porque "to"
# no es "desde", sino "hacia", que yo sepa. Pero `archivo hacia la
# salida estándar' no pega mucho. Está en otros mensajes, como el
# siguiente; no lo entiendo. - gerardo
# FIXME. Tienes razón. Es muy raro.
#: src/tar.c:544
msgid "Archive format selection:"
msgstr "Selección del formato de archivo:"

#: src/tar.c:546 tests/genfile.c:146
msgid "FORMAT"
msgstr "FORMATO"

#: src/tar.c:547
#, fuzzy
msgid "create archive of the given format"
msgstr "crea un archivo en el formato dado."

#: src/tar.c:549
msgid "FORMAT is one of the following:"
msgstr "FORMATO es uno de los siguientes:"

#: src/tar.c:550
msgid "old V7 tar format"
msgstr "formato tar V7 antiguo"

#: src/tar.c:553
msgid "GNU format as per tar <= 1.12"
msgstr "formato GNU de tar <= 1.12"

#: src/tar.c:555
msgid "GNU tar 1.13.x format"
msgstr "formato GNU tar 1.13.x"

#: src/tar.c:557
msgid "POSIX 1003.1-1988 (ustar) format"
msgstr "formato POSIX 1003.1-1988 (ustar)"

#: src/tar.c:559
msgid "POSIX 1003.1-2001 (pax) format"
msgstr "formato POSIX 1003.1-2001 (pax)"

#: src/tar.c:560
#, fuzzy
msgid "same as pax"
msgstr "Lo mismo que pax"

#: src/tar.c:563
msgid "same as --format=v7"
msgstr "lo mismo que --format=v7"

#: src/tar.c:566
msgid "same as --format=posix"
msgstr "lo mismo que --format=posix"

#: src/tar.c:567
#, fuzzy
msgid "keyword[[:]=value][,keyword[[:]=value]]..."
msgstr "palabra[[:]=valor][,palabra[[:]=valor], ...]"

#: src/tar.c:568
msgid "control pax keywords"
msgstr "palabras clave de control de pax"

#: src/tar.c:569
msgid "TEXT"
msgstr "TEXTO"

#: src/tar.c:570
#, fuzzy
msgid ""
"create archive with volume name TEXT; at list/extract time, use TEXT as a "
"globbing pattern for volume name"
msgstr ""
"crea un archivo con nombre de volumen NOMBRE. En el momento de listar/"
"extraer, utiliza TEXTO como patrón expandible"

#: src/tar.c:572
msgid "filter the archive through bzip2"
msgstr "filtra el archivo a través de bzip2"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/tar.c:574
msgid "filter the archive through gzip"
msgstr "filtra el arhivo a través de gzip"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/tar.c:578
msgid "filter the archive through compress"
msgstr "filtra el archivo a través de compress"

#: src/tar.c:580
msgid "PROG"
msgstr "PROG"

#: src/tar.c:581
msgid "filter through PROG (must accept -d)"
msgstr "filtra a través de PROG (debe aceptar -d)"

#: src/tar.c:586
msgid "Local file selection:"
msgstr "Selección del fichero local:"

#: src/tar.c:589
msgid "add given FILE to the archive (useful if its name starts with a dash)"
msgstr ""

#: src/tar.c:590
msgid "DIR"
msgstr "DIR"

#: src/tar.c:591
msgid "change to directory DIR"
msgstr "cambia al directorio DIR"

#: src/tar.c:593
#, fuzzy
msgid "get names to extract or create from FILE"
msgstr "obtiene los nombres que se van a extraer o crear del fichero NOMBRE"

#: src/tar.c:595
msgid "-T reads null-terminated names, disable -C"
msgstr "-T lee nombres terminados en nulo, desactiva -C"

#: src/tar.c:597
msgid "unquote filenames read with -T (default)"
msgstr ""

#: src/tar.c:599
msgid "do not unquote filenames read with -T"
msgstr ""

# Nota: La diferencia entre un PATRÓN y una EXPREG es que
# el primero se refiere a un "globbing pattern", es decir, patrones
# de expansión de nombres de ficheros, como * y ?, mientras que
# el segundo se refiere a expresiones regulares como las de grep,
# es decir, ^, $, ., *, etc.
#: src/tar.c:600 tests/genfile.c:132
msgid "PATTERN"
msgstr "PATRÓN"

#: src/tar.c:601
msgid "exclude files, given as a PATTERN"
msgstr "excluye ficheros, dados como un PATRÓN"

#: src/tar.c:603
msgid "exclude patterns listed in FILE"
msgstr "excluye los patrones listados en FICHERO"

#: src/tar.c:605
msgid "exclude directories containing a cache tag"
msgstr "excluye los directorios que contienen una marca de caché"

#: src/tar.c:607
msgid "avoid descending automatically in directories"
msgstr "evita descender automáticamente en los directorios"

#: src/tar.c:609
msgid "stay in local file system when creating archive"
msgstr "permanece en el sistema de ficheros locales al crear el archivo"

#: src/tar.c:611
msgid "recurse into directories (default)"
msgstr "opera recursivamente sobre los directorios (por omisión)"

#: src/tar.c:613
msgid "don't strip leading `/'s from file names"
msgstr "no elimina la `/' inicial de los nombres de ficheros"

#: src/tar.c:615
msgid "follow symlinks; archive and dump the files they point to"
msgstr ""

#: src/tar.c:616
msgid "MEMBER-NAME"
msgstr "NOMBRE-DE-MIEMBRO"

#: src/tar.c:617
msgid "begin at member MEMBER-NAME in the archive"
msgstr "comienza por el miembro NOMBRE-DE-MIEMBRO dentro del archivo"

#: src/tar.c:619
msgid "only store files newer than DATE-OR-FILE"
msgstr "almacena solamente ficheros más recientes que FECHA-O-FICHERO"

#: src/tar.c:621
msgid "DATE"
msgstr "FECHA"

#: src/tar.c:622
msgid "compare date and time when data changed only"
msgstr "compara la fecha y hora solamente cuando cambian los datos"

#: src/tar.c:623
msgid "CONTROL"
msgstr "CONTROL"

#: src/tar.c:624
msgid "backup before removal, choose version CONTROL"
msgstr "se hace un respaldo antes de borrar, escoja el CONTROL de versión"

#: src/tar.c:625 src/tar.c:696 src/tar.c:698 tests/genfile.c:162
msgid "STRING"
msgstr "CADENA"

#: src/tar.c:626
#, fuzzy
msgid ""
"backup before removal, override usual suffix ('~' unless overridden by "
"environment variable SIMPLE_BACKUP_SUFFIX)"
msgstr ""
"se hace un respaldo antes de borrar, cambiando el sufijo usual ('~' a menos "
"que se\n"
"cambie con la variable de entorno SIMPLE_BACKUP_SUFFIX)"

#: src/tar.c:631
msgid "File name transformations:"
msgstr ""

#: src/tar.c:633
#, fuzzy
msgid "strip NUMBER leading components from file names on extraction"
msgstr "elimina NÚMERO componentes iniciales de los nombres de ficheros"

#: src/tar.c:635
msgid "EXPRESSION"
msgstr ""

#: src/tar.c:636
msgid "use sed replace EXPRESSION to transform file names"
msgstr ""

#: src/tar.c:641
msgid "File name matching options (affect both exclude and include patterns):"
msgstr ""

#: src/tar.c:644
#, fuzzy
msgid "ignore case"
msgstr "la exclusión no distingue mayúsculas de minúsculas"

#: src/tar.c:646
#, fuzzy
msgid "patterns match file name start"
msgstr ""
"los patrones de exclusión encajan con el comienzo del nombre del fichero"

#: src/tar.c:648
#, fuzzy
msgid "patterns match after any `/' (default for exclusion)"
msgstr "los patrones de exclusión encajan después de cualquier / (por omisión)"

#: src/tar.c:650
#, fuzzy
msgid "case sensitive matching (default)"
msgstr "la exclusión distingue mayúsculas de minúsculas (por omisión)"

#: src/tar.c:652
msgid "use wildcards (default for exclusion)"
msgstr ""

#: src/tar.c:654
msgid "verbatim string matching"
msgstr ""

#: src/tar.c:656
#, fuzzy
msgid "wildcards do not match `/'"
msgstr "los comodines de patrones de exclusión no encajan con '/'"

#: src/tar.c:658
#, fuzzy
msgid "wildcards match `/' (default for exclusion)"
msgstr ""
"los comodines de los patrones de exclusión encajan con '/' (por omisión)"

#: src/tar.c:663
msgid "Informative output:"
msgstr "Salida informativa:"

#: src/tar.c:666
msgid "verbosely list files processed"
msgstr "lista los ficheros procesados detalladamente"

#: src/tar.c:667
#, fuzzy
msgid "[.]NUMBER"
msgstr "NÚMERO"

#: src/tar.c:668
#, fuzzy
msgid "display progress messages every NUMBERth record (default 10)"
msgstr "muestra mensajes de progreso cada 10 registros"

#: src/tar.c:671
msgid "print a message if not all links are dumped"
msgstr "muestra un mensaje si no se vuelcan todos los enlaces"

#: src/tar.c:672
msgid "SIGNAL"
msgstr ""

#: src/tar.c:673
msgid ""
"print total bytes after processing the archive; with an argument - print "
"total bytes when this SIGNAL is delivered; Allowed signals are: SIGHUP, "
"SIGQUIT, SIGINT, SIGUSR1 and SIGUSR2; the names without SIG prefix are also "
"accepted"
msgstr ""

#: src/tar.c:678
msgid "print file modification dates in UTC"
msgstr "muestra las fechas de modificación de los ficheros en UTC"

#: src/tar.c:680
msgid "send verbose output to FILE"
msgstr "envía la salida detallada a FICHERO"

#: src/tar.c:682
msgid "show block number within archive with each message"
msgstr "muestra el número de bloque dentro del archivo con cada mensaje"

#: src/tar.c:684
msgid "ask for confirmation for every action"
msgstr "pide confirmación para cada acción"

#: src/tar.c:687
#, fuzzy
msgid "show tar defaults"
msgstr "Muestra los valores predeterminados de tar"

#: src/tar.c:689
#, fuzzy
msgid ""
"when listing or extracting, list each directory that does not match search "
"criteria"
msgstr ""
"Cuando se lista o extrae, lista cada directorio que no coincida con el "
"criterio de búsqueda"

#: src/tar.c:691
msgid "show file or archive names after transformation"
msgstr ""

#: src/tar.c:694
msgid "STYLE"
msgstr ""

#: src/tar.c:695
msgid "set name quoting style; see below for valid STYLE values"
msgstr ""

#: src/tar.c:697
msgid "additionally quote characters from STRING"
msgstr ""

#: src/tar.c:699
msgid "disable quoting for characters from STRING"
msgstr ""

#: src/tar.c:704
msgid "Compatibility options:"
msgstr "Opciones de compatibilidad:"

#: src/tar.c:707
#, fuzzy
msgid ""
"when creating, same as --old-archive; when extracting, same as --no-same-"
"owner"
msgstr ""
"al crear, lo mismo que --old-archive. Al extraer, lo mismo que --no-same-"
"owner"

#: src/tar.c:712
msgid "Other options:"
msgstr "Otras opciones:"

#: src/tar.c:715
msgid "disable use of some potentially harmful options"
msgstr ""

#: src/tar.c:819
msgid "You may not specify more than one `-Acdtrux' option"
msgstr "No se puede especificar más de una opción `-Acdtrux'"

#: src/tar.c:829
msgid "Conflicting compression options"
msgstr "Opciones de compresión en conflicto"

#: src/tar.c:885
#, fuzzy, c-format
msgid "Unknown signal name: %s"
msgstr " tipo de fichero desconocido %s\n"

#: src/tar.c:909
#, fuzzy
msgid "Date sample file not found"
msgstr "No se encontró la fecha del fichero"

#: src/tar.c:917
#, c-format
msgid "Substituting %s for unknown date format %s"
msgstr "Sustituyendo %s por el formato de fecha desconocido %s"

#: src/tar.c:942
#, fuzzy, c-format
msgid "Option %s: Treating date `%s' as %s"
msgstr "Se trata la fecha `%s' como %s + %ld nanosegundo"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/tar.c:1013
#, fuzzy, c-format
msgid "%s: file list already read"
msgstr "%s: el fichero es el propio archivo; no se vuelca"

#: src/tar.c:1068
#, c-format
msgid "%s: file name read contains nul character"
msgstr ""

#: src/tar.c:1130
msgid "Valid arguments for --quoting-style options are:"
msgstr ""

#: src/tar.c:1133
msgid ""
"\n"
"*This* tar defaults to:\n"
msgstr ""
"\n"
"Las opciones predeterminadas de *esta* versión de tar son:\n"

#: src/tar.c:1166
msgid "Invalid blocking factor"
msgstr "Factor de bloqueo inválido"

#: src/tar.c:1238
msgid "Warning: the -I option is not supported; perhaps you meant -j or -T?"
msgstr "Atención: no se admite la opción -I; ¿no será -j o -T?"

#: src/tar.c:1271
msgid "Invalid tape length"
msgstr "Longitud de cinta inválida"

# No sé cómo traducir threshold. fr
# Yo tampoco (los diccionarios los tengo en casa...). sv
# Lo buscaré en un diccionario "güeno". fr
# Es "umbral", pero no sé qué c$%&# es la fecha umbral. :-( gag
# A ver si te vale así. sv
# ¿Qué tal os suena "fecha límite"?. jmg
#: src/tar.c:1303
msgid "More than one threshold date"
msgstr "Se ha especificado más de una fecha tope"

#: src/tar.c:1358 src/tar.c:1361
msgid "Invalid sparse version value"
msgstr ""

#: src/tar.c:1446
msgid "--atime-preserve='system' is not supported on this platform"
msgstr ""

#: src/tar.c:1463
msgid "--checkpoint value is not an integer"
msgstr ""

#: src/tar.c:1533
#, c-format
msgid "%s: Invalid group"
msgstr "%s: Grupo inválido"

#: src/tar.c:1540
msgid "Invalid mode given on option"
msgstr "Se ha especificado un modo no válido en la opción"

#: src/tar.c:1593
msgid "Invalid number"
msgstr "Número inválido"

#: src/tar.c:1615
msgid "Invalid owner"
msgstr "Propietario inválido"

#: src/tar.c:1649
msgid "Invalid record size"
msgstr "El tamaño del registro es inválido"

#: src/tar.c:1652
#, c-format
msgid "Record size must be a multiple of %d."
msgstr "El tamaño del registro debe ser múltiplo de %d."

#: src/tar.c:1689
msgid "Invalid number of elements"
msgstr "Número inválido de elementos"

#: src/tar.c:1709
msgid "Only one --to-command option allowed"
msgstr ""

#: src/tar.c:1785
#, fuzzy, c-format
msgid "Malformed density argument: %s"
msgstr "Argumento de densidad mal formado: '%s'"

#: src/tar.c:1811
#, fuzzy, c-format
msgid "Unknown density: `%c'"
msgstr "Densidad desconocida: '%c'"

#: src/tar.c:1828
#, c-format
msgid "Options `-[0-7][lmh]' not supported by *this* tar"
msgstr "*Esta* versión de tar no admite las opciones `-[0-7][lmh]'"

#: src/tar.c:1863
msgid "[FILE]..."
msgstr "[FICHERO]..."

#: src/tar.c:1966
#, c-format
msgid "Old option `%c' requires an argument."
msgstr "La opción antigua `%c' requiere un argumento"

#: src/tar.c:2048
msgid "--occurrence is meaningless without a file list"
msgstr "--occurrence no tiene sentido sin una lista de ficheros"

#: src/tar.c:2054
msgid "--occurrence cannot be used in the requested operation mode"
msgstr "no se puede usar --occurrence en el modo de operación solicitado"

# requieren -> necesitan. gerardo
#: src/tar.c:2084
msgid "Multiple archive files require `-M' option"
msgstr "Los archivos múltiples requieren la opción `-M'"

#: src/tar.c:2089
msgid "Cannot combine --listed-incremental with --newer"
msgstr "No se puede combinar --listed-incremental con --newer"

#: src/tar.c:2106
#, c-format
msgid "%s: Volume label is too long (limit is %lu byte)"
msgid_plural "%s: Volume label is too long (limit is %lu bytes)"
msgstr[0] ""
"%s: La etiqueta de volumen es demasiado larga (el límite es %lu byte)"
msgstr[1] ""
"%s: La etiqueta de volumen es demasiado larga (el límite es %lu bytes)"

#: src/tar.c:2119
msgid "Cannot verify multi-volume archives"
msgstr "No se pueden verificar archivos multivolumen"

#: src/tar.c:2121
msgid "Cannot verify compressed archives"
msgstr "No se pueden verificar archivos comprimidos"

#: src/tar.c:2127
msgid "Cannot use multi-volume compressed archives"
msgstr "No se pueden utilizar archivos multivolumen comprimidos"

#: src/tar.c:2133
#, fuzzy
msgid "Cannot concatenate compressed archives"
msgstr "No se pueden actualizar archivos comprimidos"

#: src/tar.c:2145
msgid "--pax-option can be used only on POSIX archives"
msgstr "--pax-option solamente se puede usar en archivos POSIX"

# Me gusta más al verrés: cobarde rechazo [de la pradera] a... gerardo
#: src/tar.c:2170
msgid "Cowardly refusing to create an empty archive"
msgstr "Rechazo cobarde a crear un archivo vacío"

#: src/tar.c:2191
msgid "Options `-Aru' are incompatible with `-f -'"
msgstr "Las opciones `-Aru' son incompatibles con `-f -'"

#: src/tar.c:2280
msgid "You must specify one of the `-Acdtrux' options"
msgstr "Debe especificar una de las opciones `-Acdtrux'"

# Antes decía:
# "La salida con error se demora por los errores anteriores
#
# Quiere decir que hubo errores, pero tar pudo seguir adelante, sin
# embargo va a salir con un estado de error por esos errores que ya pasaron.
# Una traducción:
# "Salida con error demorada desde errores anteriores" (Nicolás L.)
#: src/tar.c:2331
#, c-format
msgid "Error exit delayed from previous errors"
msgstr "Salida con error demorada desde errores anteriores"

# Eso de ¡vaya tela! ¿es una interjección que se entiende en todo el mundo
# hispanoparlante? No vaya a ser específico de Andalucía/Extremadura y...
# ¡oye, déjalo, así expandimos nuestra lengua! gerardo
# Inaceptable, alguien fuera de España no tiene idea de que diablos quiere
# decir ¡vaya tela!. Habrá que buscar alguna interhección de asco/sorpresa
# que sea más `portable'. nl
# Tenéis razón. Habrá que preguntar.
# ¡Ya lo tengo! "¡Carajo!" X-D Eso se utiliza en Colombia, México y otros
# sitios de por ahí a troche y moche, y creo que ni siquiera se entiende como
# "miembro viril masculino". Y en España creo que también se emplea, ¿no?
# (Vaale, vaaale, ¿y qué tal su eufemismo `caramba' o `caray', más neutros
# y cursis, para que no se enfade nadie? Aunque para cursis: `cáspita',
# `caracoles', `cónchales'; no diréis que no os doy opciones.) Por cierto,
# creo que la coma sobra (incluso en el original). gerardo
#: src/update.c:86
#, c-format
msgid "%s: File shrank by %s byte"
msgid_plural "%s: File shrank by %s bytes"
msgstr[0] "%s: El tamaño del fichero ha disminuido en %s byte"
msgstr[1] "%s: El tamaño del fichero ha disminuido en %s bytes"

# FIXME: Imlemented
#: src/xheader.c:160
#, fuzzy, c-format
msgid "Keyword %s is unknown or not yet implemented"
msgstr "La palabra clave %s es desconocida o no está implementada todavía"

#: src/xheader.c:186
#, c-format
msgid "Pattern %s cannot be used"
msgstr "No se puede usar el patrón %s"

#: src/xheader.c:196
#, c-format
msgid "Keyword %s cannot be overridden"
msgstr "La palabra clave %s no se puede sustituir"

#: src/xheader.c:500
#, fuzzy
msgid "Malformed extended header: missing length"
msgstr "Cabecera extendida errónea: falta un signo igual"

#: src/xheader.c:508
msgid "Extended header length is out of allowed range"
msgstr ""

#: src/xheader.c:515
#, fuzzy, c-format
msgid "Extended header length %*s is out of range"
msgstr "La cadena firmada en base 64 %s del archivo está fuera del rango %s"

#: src/xheader.c:527
#, fuzzy
msgid "Malformed extended header: missing blank after length"
msgstr ""
"Cabecera extendida errónea: falta un espacio en blanco después de la longitud"

#: src/xheader.c:535
msgid "Malformed extended header: missing equal sign"
msgstr "Cabecera extendida errónea: falta un signo igual"

#: src/xheader.c:541
#, fuzzy
msgid "Malformed extended header: missing newline"
msgstr "Cabecera extendida errónea: falta un signo igual"

#: src/xheader.c:578
#, c-format
msgid "Ignoring unknown extended header keyword `%s'"
msgstr ""

#: src/xheader.c:785
#, c-format
msgid "Generated keyword/value pair is too long (keyword=%s, length=%s)"
msgstr ""

#. TRANSLATORS: The first %s is the pax extended header keyword
#. (atime, gid, etc.).
#: src/xheader.c:817
#, fuzzy, c-format
msgid "Extended header %s=%s is out of range %s..%s"
msgstr "El valor del archivo %s está fuera del rango %s %s.%s"

#: src/xheader.c:948 src/xheader.c:978 src/xheader.c:1291
#, fuzzy, c-format
msgid "Malformed extended header: invalid %s=%s"
msgstr "Cabecera extendida errónea: falta un signo igual"

#: src/xheader.c:1244 src/xheader.c:1269 src/xheader.c:1319
#, fuzzy, c-format
msgid "Malformed extended header: excess %s=%s"
msgstr "Cabecera extendida errónea: falta un signo igual"

#: src/xheader.c:1332
#, fuzzy, c-format
msgid "Malformed extended header: invalid %s: unexpected delimiter %c"
msgstr "Cabecera extendida errónea: falta un signo igual"

#: src/xheader.c:1342
#, fuzzy, c-format
msgid "Malformed extended header: invalid %s: odd number of values"
msgstr "Cabecera extendida errónea: falta un signo igual"

# Acepto sugerencias para el `test suite'. sv
# "test suite"="paquete/conjunto de pruebas/análisis", en cualquier
# combinación. jmg
#: tests/genfile.c:109
#, fuzzy
msgid ""
"genfile manipulates data files for GNU paxutils test suite.\n"
"OPTIONS are:\n"
msgstr "Genera ficheros de datos para el conjunto de pruebas de GNU tar.\n"

#: tests/genfile.c:123
#, fuzzy
msgid "File creation options:"
msgstr "Otras opciones:"

#: tests/genfile.c:124 tests/genfile.c:135
msgid "SIZE"
msgstr ""

#: tests/genfile.c:125
#, fuzzy
msgid "Create file of the given SIZE"
msgstr "crea un archivo en el formato dado."

#: tests/genfile.c:127
#, fuzzy
msgid "Write to file NAME, instead of standard output"
msgstr "extrae los ficheros a la salida estándar"

#: tests/genfile.c:129
#, fuzzy
msgid "Read file names from FILE"
msgstr "Leídos %s bytes como %s"

#: tests/genfile.c:131
#, fuzzy
msgid "-T reads null-terminated names"
msgstr "-T lee nombres terminados en nulo, desactiva -C"

#: tests/genfile.c:133
msgid "Fill the file with the given PATTERN. PATTERN is 'default' or 'zeros'"
msgstr ""

#: tests/genfile.c:136
msgid "Size of a block for sparse file"
msgstr ""

#: tests/genfile.c:138
msgid "Generate sparse file. Rest of the command line gives the file map."
msgstr ""

#: tests/genfile.c:144
msgid "File statistics options:"
msgstr ""

#: tests/genfile.c:147
msgid "Print contents of struct stat for each given file. Default FORMAT is: "
msgstr ""

#: tests/genfile.c:154
msgid "Synchronous execution options:"
msgstr ""

#: tests/genfile.c:157
msgid ""
"Execute given COMMAND. Useful with --checkpoint and one of --cut, --append, "
"--touch"
msgstr ""

#: tests/genfile.c:160
msgid "Perform given action (see below) upon reaching checkpoint NUMBER"
msgstr ""

#: tests/genfile.c:163
msgid "Set date for next --touch option"
msgstr ""

#: tests/genfile.c:166
msgid "Display executed checkpoints and exit status of COMMAND"
msgstr ""

#: tests/genfile.c:171
msgid ""
"Synchronous execution actions. These are executed when checkpoint number "
"given by --checkpoint option is reached."
msgstr ""

#: tests/genfile.c:174
msgid ""
"Truncate FILE to the size specified by previous --length option (or 0, if it "
"is not given)"
msgstr ""

#: tests/genfile.c:178
msgid "Append SIZE bytes to FILE. SIZE is given by previous --length option."
msgstr ""

#: tests/genfile.c:181
#, fuzzy
msgid "Update the access and modification times of FILE"
msgstr "%s: No se pueden cambiar las fechas de acceso y modificación"

#: tests/genfile.c:184
#, fuzzy
msgid "Execute COMMAND"
msgstr "ORDEN"

#: tests/genfile.c:234
#, fuzzy, c-format
msgid "Invalid size: %s"
msgstr "Marca de tiempo inválida"

#: tests/genfile.c:239
#, fuzzy, c-format
msgid "Number out of allowed range: %s"
msgstr "Número de nodo-i fuera de rango"

#: tests/genfile.c:242
#, c-format
msgid "Negative size: %s"
msgstr ""

#: tests/genfile.c:255 tests/genfile.c:544
#, c-format
msgid "stat(%s) failed"
msgstr ""

#: tests/genfile.c:345
#, c-format
msgid "Error parsing number near `%s'"
msgstr ""

#: tests/genfile.c:351
#, fuzzy, c-format
msgid "Unknown date format"
msgstr "Error del sistema desconocido"

#: tests/genfile.c:374
msgid "[ARGS...]"
msgstr ""

#: tests/genfile.c:411 tests/genfile.c:448 tests/genfile.c:498
#: tests/genfile.c:648 tests/genfile.c:662
#, fuzzy, c-format
msgid "cannot open `%s'"
msgstr "No se puede abrir %s"

#: tests/genfile.c:431
#, c-format
msgid "file name contains null character"
msgstr ""

#: tests/genfile.c:495
#, c-format
msgid "cannot generate sparse files on standard output, use --file option"
msgstr ""

#: tests/genfile.c:571
#, c-format
msgid "incorrect mask (near `%s')"
msgstr ""

#: tests/genfile.c:577 tests/genfile.c:610
#, fuzzy, c-format
msgid "Unknown field `%s'"
msgstr " tipo de fichero desconocido %s\n"

# Uff, a lo mejor se asusta el usuario si ponemos 'no se pudo leer con stat()
# el estado del fichero em+
# stat() es una primitiva Unix que acaba de fallar; también podría
# ser: "No se puede hacer stat() del fichero %s", o "stat() ha fallado..."
# Aunque tal como está es más descriptivo para el neófito, desde
# luego. gag
#: tests/genfile.c:637
#, fuzzy, c-format
msgid "cannot set time on `%s'"
msgstr "No se puede leer el estado del fichero %s"

#: tests/genfile.c:791
#, c-format
msgid "Command exited successfully\n"
msgstr ""

#: tests/genfile.c:793
#, fuzzy, c-format
msgid "Command failed with status %d\n"
msgstr "El proceso hijo terminó con la señal %d"

#: tests/genfile.c:797
#, c-format
msgid "Command terminated on signal %d\n"
msgstr ""

#: tests/genfile.c:799
#, c-format
msgid "Command stopped on signal %d\n"
msgstr ""

#: tests/genfile.c:802
#, c-format
msgid "Command dumped core\n"
msgstr ""

#: tests/genfile.c:805
#, c-format
msgid "Command terminated\n"
msgstr ""

#: tests/genfile.c:837
#, fuzzy, c-format
msgid "--stat requires file names"
msgstr "--Nombres de fichero modificados--\n"

#: tests/genfile.c:850
#, c-format
msgid "too many arguments"
msgstr ""

#~ msgid ""
#~ "This program comes with NO WARRANTY, to the extent permitted by law.\n"
#~ "You may redistribute it under the terms of the GNU General Public "
#~ "License;\n"
#~ "see the file named COPYING for details."
#~ msgstr ""
#~ "Este programa viene sin NINGUNA GARANTÍA, hasta donde permite la ley.\n"
#~ "Puede redistribuirse bajo los términos de la Licencia Pública General de "
#~ "GNU;\n"
#~ "vea el fichero llamado COPYING para más información."

# "no reconocida" me parecía muy suave para "garbage". sv
# OJO: Casi el mismo mensaje.
#~ msgid "rmtd: Garbage command %c\n"
#~ msgstr "rmtd: Orden ininteligible %c\n"

#~ msgid "WARNING: No volume header"
#~ msgstr "ATENCIÓN: No hay cabecera de volumen"

# Me queda la duda de si lo que es visible es el error o el nombre largo... sv
#~ msgid "Visible long name error"
#~ msgstr "Error de nombre largo visible"

#~ msgid "Time stamp out of range"
#~ msgstr "Marca de tiempo fuera de rango"

#~ msgid "Device number out of range"
#~ msgstr "Número de dispositivo fuera de rango"

# FIXME. Hay otro que se parece muchísimo. sv
#~ msgid "Visible longname error"
#~ msgstr "Error de nombre largo visible"

#~ msgid "Missing file name after -C"
#~ msgstr "Falta el nombre del fichero después de -C"

#~ msgid "don't change access times on dumped files"
#~ msgstr "no cambia la fecha de acceso en los ficheros volcados"

#~ msgid "extract permissions information"
#~ msgstr "extrae la información de los permisos"

#~ msgid "do not extract permissions information"
#~ msgstr "no extrae la información de los permisos"

#~ msgid "FILE-OF-NAMES"
#~ msgstr "FICHERO-DE-NOMBRES"

#~ msgid "exclude patterns are plain strings"
#~ msgstr "los patrones de exclusión son cadenas normales"

#~ msgid "dump instead the files symlinks point to"
#~ msgstr ""
#~ "vuelca los ficheros a los que apuntan los enlaces simbólicos, en lugar de "
#~ "los enlaces"

#~ msgid "same as -N"
#~ msgstr "lo mismo que -N"

#~ msgid "exclude patterns use wildcards (default)"
#~ msgstr "los patrones de exclusión usan comodines (por omisión)"

#~ msgid "print total bytes written while creating archive"
#~ msgstr "muestra el total de bytes escritos cuando se crea un archivo"

#~ msgid "Print license and exit"
#~ msgstr "Muestra la licencia y finaliza"

#~ msgid ""
#~ "Based on the work of John Gilmore and Jay Fenlason. See AUTHORS\n"
#~ "for complete list of authors.\n"
#~ msgstr ""
#~ "Basado en el trabajo de John Gilmore y Jay Fenlason. Vea AUTHORS\n"
#~ "para una lista completa de autores.\n"

#~ msgid ""
#~ "   GNU tar is free software; you can redistribute it and/or modify\n"
#~ "   it under the terms of the GNU General Public License as published by\n"
#~ "   the Free Software Foundation; either version 2 of the License, or\n"
#~ "   (at your option) any later version.\n"
#~ "\n"
#~ "   GNU tar is distributed in the hope that it will be useful,\n"
#~ "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
#~ "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
#~ "   GNU General Public License for more details.\n"
#~ "\n"
#~ "   You should have received a copy of the GNU General Public License\n"
#~ "   along with GNU tar; if not, write to the Free Software\n"
#~ "   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  "
#~ "USA\n"
#~ "\n"
#~ msgstr ""
#~ "   GNU tar es software libre; puede redistribuirse y/o modificarse\n"
#~ "   bajo los términos de la Licencia Pública General de GNU tal y como\n"
#~ "   se publica por la Free Software Foundation; bien en la versión 2\n"
#~ "   de la Licencia, o (a su elección) cualquier versión posterior.\n"
#~ "\n"
#~ "   GNU tar se distribuye con la esperanza de que sea útil, pero\n"
#~ "   SIN NINGUNA GARANTÍA; ni siquiera la garantía implícita de\n"
#~ "   COMERCIABILIDAD o IDONEIDAD PARA UN FIN DETERMINADO. Véase la\n"
#~ "   Licencia Pública General de GNU para más detalles.\n"
#~ "\n"
#~ "   Usted debería haber recibido una copia de la Licencia Pública General\n"
#~ "   de GNU junto con GNU tar; en caso contrario, escriba a la Free "
#~ "Software\n"
#~ "   Foundation, Inc.  59 Temple Place, Suite 330, Boston, MA 02111-1307 EE."
#~ "UU.\n"

#~ msgid "Semantics of -l option will change in the future releases."
#~ msgstr "El significado de la opción -l cambiará en versiones posteriores."

#~ msgid "Please use --one-file-system option instead."
#~ msgstr "Por favor utilice la opción --one-file-system en su lugar."

#~ msgid "Warning: the -y option is not supported; perhaps you meant -j?"
#~ msgstr "Atención: no se admite la opción -y; ¿no será -j?"

#~ msgid "Error in writing to standard output"
#~ msgstr "Error al escribir en la salida estándar"

# Sugerencia: para archivos -> para los archivos. sv
# Sugerencia: Estandarizar la traducción de "added files". sv
# En el  --mode=CHANGES  no sé qué poner... sv
# En vez de "force"->"establece", yo dejaría el significado
# original ->"fuerza". jmg
# force es forzar, ¡no establecer! nl
# Gerardo, ¿qué opinas de "forzar"? sv
# Hombre, desde luego to force es forzar u obligar; la verdad es que no sé
# por qué el autor original dice "force" y no "set". Quizá porque si no se
# pusieran estas opciones los ficheros tendrían otros atributos que vendrían
# impuestos por el umask, el UID/GID del usuario, etc., y con esto se "fuerza",
# se cambia esta situación. No es lo mismo que establecer, que sería poner
# esos atributos partiendo de cero. Creo que ése es el matiz, y para conservar-
# lo habría que poner "fuerza NOMBRE como propietario...", etc., o bien
# "obliga a que sea NOMBRE el propietario...", etc. gerardo
# # usa -> emplea - gerardo
#~ msgid ""
#~ "\n"
#~ "Handling of file attributes:\n"
#~ "      --owner=NAME             force NAME as owner for added files\n"
#~ "      --group=NAME             force NAME as group for added files\n"
#~ "      --mode=CHANGES           force (symbolic) mode CHANGES for added "
#~ "files\n"
#~ "      --atime-preserve         don't change access times on dumped files\n"
#~ "  -m, --modification-time      don't extract file modified time\n"
#~ "      --same-owner             try extracting files with the same "
#~ "ownership\n"
#~ "      --no-same-owner          extract files as yourself\n"
#~ "      --numeric-owner          always use numbers for user/group names\n"
#~ "  -p, --same-permissions       extract permissions information\n"
#~ "      --no-same-permissions    do not extract permissions information\n"
#~ "      --preserve-permissions   same as -p\n"
#~ "  -s, --same-order             sort names to extract to match archive\n"
#~ "      --preserve-order         same as -s\n"
#~ "      --preserve               same as both -p and -s\n"
#~ msgstr ""
#~ "\n"
#~ "Manejo de los atributos de los ficheros:\n"
#~ "      --owner=NOMBRE           establece NOMBRE como propietario para "
#~ "los\n"
#~ "                               ficheros que se añaden\n"
#~ "      --group=NOMBRE           establece NOMBRE como grupo para los "
#~ "ficheros que\n"
#~ "                               se añaden\n"
#~ "      --mode=CAMBIOS           establece CAMBIOS como modo (simbólico) "
#~ "para los\n"
#~ "                               ficheros que se añaden\n"
#~ "      --atime-preserve         no cambia la fecha de acceso en los "
#~ "ficheros\n"
#~ "                               volcados\n"
#~ "  -m, --modification-time      no extrae la fecha de modificación de "
#~ "ficheros\n"
#~ "      --same-owner             intenta extraer ficheros con el mismo "
#~ "propietario\n"
#~ "      --no-same-owner          extrae los ficheros como uno mismo\n"
#~ "      --numeric-owner          siempre utiliza números para nombres de\n"
#~ "                               usuario/grupo\n"
#~ "  -p, --same-permissions       extrae la información de los permisos\n"
#~ "      --no-same-permissions    no extrae la información de los permisos\n"
#~ "      --preserve-permissions   igual que -p\n"
#~ "  -s, --same-order             ordena los nombres a extraer para "
#~ "coincidir con\n"
#~ "                               el archivo\n"
#~ "      --preserve-order         igual que -s\n"
#~ "      --preserve               igual que -p y -s a la vez\n"

# ¿globbing = globales? sv
# Me parece una buena traducción, es algo que engloba a un grupo. fr
#
# globbing es, por ejemplo, lo que hace el shell cuando pones asteriscos:
# Cuando haces "cat *", el shell se encarga de expandir el *
# en lo que corresponda, y se lo da a cat ya traducido.
# Esto más que globalizar me suena a expandir, no sé.
# Si quieres déjalo que lo vea otro. sv
# Vid. mi comentario del mensaje anterior. gerardo
# quita -> elimina. sv
#~ msgid ""
#~ "\n"
#~ "Local file selection:\n"
#~ "  -C, --directory=DIR          change to directory DIR\n"
#~ "  -T, --files-from=NAME        get names to extract or create from file "
#~ "NAME\n"
#~ "      --null                   -T reads null-terminated names, disable -"
#~ "C\n"
#~ "      --exclude=PATTERN        exclude files, given as a PATTERN\n"
#~ "  -X, --exclude-from=FILE      exclude patterns listed in FILE\n"
#~ "      --anchored               exclude patterns match file name start "
#~ "(default)\n"
#~ "      --no-anchored            exclude patterns match after any /\n"
#~ "      --ignore-case            exclusion ignores case\n"
#~ "      --no-ignore-case         exclusion is case sensitive (default)\n"
#~ "      --wildcards              exclude patterns use wildcards (default)\n"
#~ "      --no-wildcards           exclude patterns are plain strings\n"
#~ "      --wildcards-match-slash  exclude pattern wildcards match "
#~ "'/' (default)\n"
#~ "      --no-wildcards-match-slash exclude pattern wildcards do not match "
#~ "'/'\n"
#~ "  -P, --absolute-names         don't strip leading `/'s from file names\n"
#~ "  -h, --dereference            dump instead the files symlinks point to\n"
#~ "      --no-recursion           avoid descending automatically in "
#~ "directories\n"
#~ "  -l, --one-file-system        stay in local file system when creating "
#~ "archive\n"
#~ "  -K, --starting-file=NAME     begin at file NAME in the archive\n"
#~ "      --strip-path=NUM         strip NUM leading components from file "
#~ "names\n"
#~ "                               before extraction\n"
#~ msgstr ""
#~ "\n"
#~ "Selección de fichero local:\n"
#~ "  -C, --directory DIR         cambia al directorio DIR\n"
#~ "  -T, --files-from=NOMBRE     obtiene los nombres a extraer o crear del\n"
#~ "                              archivo NOMBRE\n"
#~ "      --null                  -T lee nombres terminados en cero, "
#~ "deshabilita -C\n"
#~ "      --exclude=PATRÓN        excluye ficheros, dados como un PATRÓN\n"
#~ "  -X, --exclude-from=FICHERO  excluye patrones listados en FICHERO\n"
#~ "      --anchored              los patrones de exclusión encajan desde el\n"
#~ "                              comienzo del nombre de fichero "
#~ "(predeterminado)\n"
#~ "      --no-anchored           los patrones de exclusión encajan después "
#~ "de\n"
#~ "                              cualquier /\n"
#~ "      --ignore-case           la exclusión considera iguales minúsculas "
#~ "y\n"
#~ "                              mayúsculas\n"
#~ "      --no-ignore-case        la exclusión distingue minúsculas de "
#~ "mayúsculas\n"
#~ "                              (predeterminado)\n"
#~ "      --wildcards             los patrones de exclusión incluyen "
#~ "comodines\n"
#~ "                              (predeterminado)\n"
#~ "      --no-wildcards          los patrones de exclusión son cadenas "
#~ "normales\n"
#~ "      --wildcards-match-slash los comodines de los patrones de exclusión\n"
#~ "                              encajan con '/' (predeterminado)\n"
#~ "      --wildcards-match-slash los comodines de los patrones de exclusión\n"
#~ "                              no encajan con '/'\n"
#~ "  -P, --absolute-names        no elimina las '/'s iniciales de los "
#~ "nombres de\n"
#~ "                              fichero\n"
#~ "  -h, --dereference           vuelca en su lugar los ficheros a los que "
#~ "apuntan\n"
#~ "                              los enlaces simbólicos.\n"
#~ "      --no-recurse            evita descender automáticamente en "
#~ "directorios\n"
#~ "  -l, --one-file-system       permanece en el sistema de ficheros local\n"
#~ "                              cuando se crea el archivo\n"
#~ "  -K, --starting-file=NOMBRE  comienza en el fichero NOMBRE del archivo\n"
#~ "      --strip-path=NÚM        elimina NÚM componentes iniciales de los "
#~ "nombres\n"
#~ "                              de los ficheros antes de la extracción\n"

# # "más nuevos"->"más recientes". En el info de tar1.11.8 explica un poco más las
# # opciones --newer-*, sin limitar a "store", sino hablando en general de
# # cualquier operación. En el --newer-mtime debería ser --newer-mtime=DATE, y
# # dice que "limita la operación a los ficheros modificados después de la
# # fecha DATE"... ¿?. jmg
#~ msgid ""
#~ "  -N, --newer=DATE-OR-FILE     only store files newer than DATE-OR-FILE\n"
#~ "      --newer-mtime=DATE       compare date and time when data changed "
#~ "only\n"
#~ "      --after-date=DATE        same as -N\n"
#~ msgstr ""
#~ "  -N, --newer=FECHA-O-FICHERO sólo almacena los ficheros más recientes "
#~ "que FECHA-O-FICHERO\n"
#~ "      --newer-mtime=FECHA     compara la fecha y hora en que los datos "
#~ "cambiaron\n"
#~ "      --after-date=FECHA      igual que -N\n"

#~ msgid ""
#~ "      --backup[=CONTROL]       backup before removal, choose version "
#~ "control\n"
#~ "      --suffix=SUFFIX          backup before removal, override usual "
#~ "suffix\n"
#~ msgstr ""
#~ "      --backup[=CONTROL]      copia de seguridad antes de eliminar, "
#~ "elige\n"
#~ "                              el control de versión\n"
#~ "      --suffix=SUFIJO         copia de seguridad antes de eliminar, pasa "
#~ "por\n"
#~ "                              alto el sufijo habitual\n"

# # print -> ¿muestra o imprime? Prefiero muestra, pero manténgase
# # siempre; ¡al menos en un mismo mensaje! gag
# Lo de "prolijamente" suena regular. En diffutils hay una laaarga discusión
# sobre ello. Yo usaría "verbosely"->"detalladamente" o "con detalle". jmg
# los bytes totales escritos -> el total de bytes escritos. nl
# O los bytes escritos en total, bien. gerardo
#~ msgid ""
#~ "\n"
#~ "Informative output:\n"
#~ "      --help            print this help, then exit\n"
#~ "      --version         print tar program version number, then exit\n"
#~ "  -v, --verbose         verbosely list files processed\n"
#~ "      --checkpoint      print directory names while reading the archive\n"
#~ "      --check-links     print a message if not all links are dumped\n"
#~ "      --totals          print total bytes written while creating archive\n"
#~ "      --index-file=FILE send verbose output to FILE\n"
#~ "      --utc             print file modification dates in UTC\n"
#~ "  -R, --block-number    show block number within archive with each "
#~ "message\n"
#~ "  -w, --interactive     ask for confirmation for every action\n"
#~ "      --confirmation    same as -w\n"
#~ msgstr ""
#~ "\n"
#~ "Salida de información:\n"
#~ "     --help             muestra esta ayuda, y finaliza\n"
#~ "     --version          informa de la versión y finaliza\n"
#~ " -v, --verbose          lista prolijamente los ficheros procesados\n"
#~ "     --checkpoint       muestra los nombres de directorio al leer el "
#~ "archivo\n"
#~ "     --check-links      muestra un mensaje si no se vuelcan todos los "
#~ "enlaces\n"
#~ "     --totals           muestra los bytes escritos en total al crear el "
#~ "archivo\n"
#~ "     --index-file=FICHERO envía una salida detallada a FICHERO\n"
#~ "     --utc              muestra las fechas de modificación en UTC\n"
#~ " -R, --block-number     muestra el número de bloque en el archivo con "
#~ "cada mensaje\n"
#~ " -w, --interactive      pide confirmación para cada acción\n"
#~ "     --confirmation     igual que -w\n"

# por defecto -> por omisión, de forma predeterminada
# HOST -> HUÉSPED, ANFITRIÓN (aquí estoy más perdido que el barco 'el
# arroz, ya lo sé; como con shell y script). gag
#~ msgid ""
#~ "\n"
#~ "ARCHIVE may be FILE, HOST:FILE or USER@HOST:FILE; DATE may be a textual "
#~ "date\n"
#~ "or a file name starting with `/' or `.', in which case the file's date is "
#~ "used.\n"
#~ "*This* `tar' defaults to `--format=%s -f%s -b%d'.\n"
#~ msgstr ""
#~ "\n"
#~ "GNU tar no puede leer ni generar archivos `--posix'. Si POSIXLY_CORRECT "
#~ "está\n"
#~ "definido en el entorno, las extensiones GNU se deshabilitan con `--"
#~ "posix'.\n"
#~ "El soporte para POSIX está sólo parcialmente implementado, no se debe "
#~ "contar \n"
#~ "con él aún.\n"
#~ "ARCHIVO puede ser FICHERO, HOST:FICHERO o USUARIO@HOST:FICHERO; FECHA "
#~ "puede ser\n"
#~ "una fecha textual, o un nombre de fichero que comience con `/' o con `.', "
#~ "en\n"
#~ "cuyo caso se utiliza la fecha del fichero.\n"
#~ "*Este* `tar' utiliza `--format=%s -f%s -b%d' por omisión.\n"

#~ msgid "Written by John Gilmore and Jay Fenlason."
#~ msgstr "Escrito por John Gilmore y Jay Fenlason."

#~ msgid "Cannot close"
#~ msgstr "No se puede cerrar"

# FIXME. Comunicar al autor. Con suerte quedará como un mensaje
# parecido que hay en fileutils: "fork system call failed".
# La solución de fileutils no me acaba de convencer (era "llamada
# a fork()" ). Yo pondría: "No se puede crear proceso hijo (fork)"
# que responde a la idea del fork y el paréntesis aclara. jmg
# Pero eso sería "Cannot create child process"...
# Yo creo que la solución de fileutils es la mejor.
# Tanto es así que lo pongo igual que allí. sv
# Literalmente es "No puedo bifurcar", pero como sabemos que
# `bifurcar' se refiere a la primitiva `fork()', está bien como está,
# salvo que se debería conservar la mayúscula inicial, y para mi gusto,
# simplificar, respetando el mensaje original: "Fallo en fork()" - gerardo
# Pongo la mayúscula inicial, pero antes de ser tan respetuoso con el original
# consultaré con el autor. sv
#~ msgid "Cannot dup"
#~ msgstr "Falló la llamada al sistema `dup'"

#~ msgid "Cannot use compressed or remote archives"
#~ msgstr "No se pueden usar archivos comprimidos ni remotos"

# ¿Por qué en todo lugar donde dice "child" se traduce como "proceso hijo" y
# no como "hijo" directamente? nl
# Para que esté más claro. ¿es demasiado libre la traducción? sv
# ¿Gerardo?
# Hola. Hay dos posturas a la hora de traducir:
# a) respetar escrupulosamente el mensaje original y traducir
#       literalmente, o casi.
# b) buscar la mejor interpretación de forma que un hispanohablante lo
#       entienda lo mejor posible, aunque se "corrija" al autor; siempre
#       sin cambiar el sentido o la idea del mensaje, claro.
# Yo prefiero (b) generalmente. Está claro que aquí child se refiere a un
# proceso, un proceso derivado de otro, proceso hijo. Daría igual dejar hijo
# solamente, pero así está mejor expresado. Me gusta más.
#~ msgid "tar (child)"
#~ msgstr "tar (proceso hijo)"

#~ msgid "tar (grandchild)"
#~ msgstr "tar (proceso nieto)"

#~ msgid "Child returned status %d"
#~ msgstr "El proceso hijo devolvió el estado %d"

#~ msgid "Member names contain `..'"
#~ msgstr "Los nombres contienen `..'"

#~ msgid "%s: Member name contains `..'"
#~ msgstr "%s: El nombre contiene `..'"

# Nota aclaratoria: (Gerardo)
# Incluida no lleva tilde.
# Ni ruido ni huida ni güiro (un instrumento musical cubano).
# Sí se parte en in-clu-i-da, pero sin tilde. No existe el hiato.
# Mira en un diccionario `ruido' a ver si tiene tilde, y considera si
# no es el mismo caso (Rui-do no: ru-i-do).
#
# Más arriba has usado "implies"->"implica", así que aquí
# sería "implied by"->"implicada por", o modificar lo otro. jmg
# Pero es que implica suena bien pero implicada por suena fatal. sv
#~ msgid "Obsolete option, now implied by --blocking-factor"
#~ msgstr "Opción obsoleta, ahora incluida en --blocking-factor"

# Pregunta: ¿qué es reemplazado/a el nombre o la opción? sv
# Creo que es el nombre. fr
# # El nombre de la opción; lo que pasa es que en el mensaje en español
# # no se entiende muy bien. Quizá: nombre obsoleto de la opción
# # remplazado por -- ... gag
#~ msgid "Obsolete option name replaced by --blocking-factor"
#~ msgstr "Nombre de opción obsoleta reemplazado por --blocking-factor"

# # Ver msj. anterior
#~ msgid "Obsolete option name replaced by --read-full-records"
#~ msgstr "Nombre de opción obsoleta reemplazado por --read-full-records"

#~ msgid "Obsolete option name replaced by --touch"
#~ msgstr "Nombre de opción obsoleta reemplazado por --touch"

#~ msgid "Conflicting archive format options"
#~ msgstr "Opciones de formato de archivo en conflicto"

#~ msgid "Obsolete option name replaced by --absolute-names"
#~ msgstr "Nombre de opción obsoleta reemplazado por --absolute-names"

#~ msgid "Obsolete option name replaced by --block-number"
#~ msgstr "Nombre de opción obsoleta reemplazado por --block-number"

#~ msgid "Obsolete option name replaced by --backup"
#~ msgstr "Nombre de opción obsoleta reemplazado por --backup"

#~ msgid ""
#~ "If a long option shows an argument as mandatory, then it is mandatory\n"
#~ "for the equivalent short option also.\n"
#~ "\n"
#~ "  -l, --file-length=LENGTH   LENGTH of generated file\n"
#~ "  -p, --pattern=PATTERN      PATTERN is `default' or `zeros'\n"
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ msgstr ""
#~ "Los argumentos obligatorios para las opciones largas son también "
#~ "obligatorios\n"
#~ "para las opciones cortas.\n"
#~ "\n"
#~ "  -l, --file-length=LONGITUD  LONGITUD del fichero generado\n"
#~ "  -p, --pattern=PATRÓN        PATRÓN es `default' o `zeros'\n"
#~ "      --help                  muestra esta ayuda y sale\n"
#~ "      --version               informa de la versión y finaliza\n"

#~ msgid "Written by F. Pinard."
#~ msgstr "Escrito por François Pinard."

#~ msgid "Ambiguous pattern `%s'"
#~ msgstr "El patrón `%s' es ambiguo"

# Me encantaría poder incluir tos propuestas de usar el \372 ( aspa ) y
# el (C) , veremos si lo hacemos algún día. em+
# Estaría bien cambiar el '(C)' por '©', que es otro carácter de
# ISO-Latin1. Como los yanquis usan el ASCII (US ISO-646), que es de
# 7 bits, no lo pueden usar; nosotros sí. gerardo
# Pues eso: que si os encanta, ¿por qué no lo hacéis? ¿Cuál es el problema?
# Bueno, vale, de acuerdo... sv
#~ msgid "Copyright %d Free Software Foundation, Inc."
#~ msgstr "© %d Free Software Foundation, Inc."

#~ msgid ""
#~ "This is free software; see the source for copying conditions.  There is "
#~ "NO\n"
#~ "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR "
#~ "PURPOSE.\n"
#~ msgstr ""
#~ "Esto es software libre; vea el código fuente para las condiciones de "
#~ "copia.\n"
#~ "No hay NINGUNA garantía; ni siquiera de COMERCIABILIDAD o IDONEIDAD PARA "
#~ "UN\n"
#~ "FIN DETERMINADO.\n"

#~ msgid "Write to compression program short %lu bytes"
#~ msgstr "La escritura al programa de compresión acorta %lu bytes"

#~ msgid "Removing `%.*s' prefix from member names"
#~ msgstr "Eliminando el prefijo `%.*s' de los nombres"

#~ msgid "Archive contains future timestamp %s"
#~ msgstr "El archivo contiene la marca de tiempo en el futuro %s"

#~ msgid "%s: Cannot symlink %s %s"
#~ msgstr "%s: No se puede crear el enlace simbólico %s %s"

#~ msgid "Invalid group given on option"
#~ msgstr "Se ha especificado un grupo no válido en la opción"

#~ msgid "Invalid owner given on option"
#~ msgstr "Se ha especificado un propietario no válido en la opción"

#~ msgid "Cannot close file descriptor"
#~ msgstr "No se puede cerrar el descriptor de fichero"

#~ msgid "Cannot properly duplicate %s"
#~ msgstr "No se puede duplicar %s correctamente"

#~ msgid "(child) Pipe to stdin"
#~ msgstr "(proceso hijo) Se abre una tubería desde la entrada estándar"

#~ msgid "Archive to stdout"
#~ msgstr "Archivo hacia la salida estándar"

#~ msgid "((child)) Pipe to stdout"
#~ msgstr "((proceso hijo)) Se abre una tubería hacia la salida estándar"

#~ msgid "(grandchild) Pipe to stdin"
#~ msgstr "(proceso nieto) Se abre una tubería desde la entrada estándar"

#~ msgid "(child) Pipe to stdout"
#~ msgstr "(proceso hijo) Se vuelca el resultado por la salida estándar"

#~ msgid "((child)) Pipe to stdin"
#~ msgstr "((proceso hijo)) Se abre una tubería desde la entrada estándar"

#~ msgid "(grandchild) Pipe to stdout"
#~ msgstr "(proceso nieto) Se abre una tubería hacia la salida estándar"

#~ msgid "Only wrote %lu of %lu bytes to %s"
#~ msgstr "Sólo se escribieron %lu de %lu bytes en %s"

# FIXME: No queda claro si es al cerrar, cerrando, cierre, o qué. sv
#~ msgid "WARNING: %s: close (%d, %d)"
#~ msgstr "ATENCIÓN: %s: se cierra (%d, %d)"

#~ msgid "Cannot allocate memory for diff buffer of %lu bytes"
#~ msgstr ""
#~ "No se puede asignar memoria para el búfer de diferencias de %lu bytes"

# Lo mismo que con stat() em+
# seek() es otra función. seek = "hacer seek()" ¡Estos
# angloparlantes!
#~ msgid "Cannot seek to %s in file %s"
#~ msgstr "No se puede acceder a la posición %s en el fichero %s"

#~ msgid "Wrote %s of %s bytes to file %s"
#~ msgstr "Se escribieron %s de %s bytes en el fichero %s"

#~ msgid "lseek error at byte %s in file %s"
#~ msgstr "Error de lectura en el byte %s en el fichero %s"

# "se rellena" debería ser "rellenando". "se rellena" puede entenderse como
# varias cosas, no queda claro que es lo que se esta haciendo, podría indicar
# lo que se suele hacer.. =)   "rellenando con ceros" es perfecto y es
# exactamente lo que está escrito en el original. sv
#
# Que sí, reconozco que la traducción es un poco libre.
# Pero mi intención es que el programa diga lo que va haciendo, no lo que ya
# ha hecho. Ni siquiera el original es consistente en los modos verbales. sv
#~ msgid "File %s shrunk, padding with zeros"
#~ msgstr "El tamaño del fichero %s ha disminuido, se rellena con ceros"

# OK em+
# Can't = no se puede; couldn't: no se ha podido. gag
# O no se pudo. sv
# Esa forma verbal se debería usar para cosas ocurridas hace mucho más tiempo.
# No pude hacer la Primera Comunión vestido de hombre-rana, no he podido
# escribir esta frase en caracteres jeroglíficos. gag
#
#~ msgid "Cannot reposition archive file"
#~ msgstr "No se puede reposicionar el archivo"

#~ msgid "%s: Cannot lchown to uid %lu gid %lu"
#~ msgstr ""
#~ "%s: No se puede cambiar el propietario y grupo con `lchown' a uid %lu gid "
#~ "%lu"

#~ msgid "%s: Cannot chown to uid %lu gid %lu"
#~ msgstr ""
#~ "%s: No se puede cambiar el propietario y grupo con `chown' a uid %lu gid %"
#~ "lu"

#~ msgid "%s: lseek error at byte %s"
#~ msgstr "%s: error de desplazamiento en el byte %s"

#~ msgid "%s: Could only write %s of %s bytes"
#~ msgstr "%s: Sólo se pudieron escribir %s de %s bytes"

#~ msgid "Error while deleting %s"
#~ msgstr "Error al borrar %s"

#~ msgid "Only wrote %lu of %lu bytes to file %s"
#~ msgstr "Sólo se escribieron %lu de %lu bytes al archivo %s"

#~ msgid "Renaming previous %s to %s\n"
#~ msgstr "Se renombra el anterior %s como %s\n"

#~ msgid "%s: Cannot rename for backup"
#~ msgstr "%s: No se puede renombrar para hacer una copia de seguridad"

#~ msgid "%s: Cannot rename from backup"
#~ msgstr "%s: No se puede renombrar de la copia de seguridad"

# FIXME. No es traducible.
#~ msgid "Cannot %s %s"
#~ msgstr "No se puede %s %s"

#~ msgid "Read error at byte %s reading %lu bytes in file %s"
#~ msgstr "Error de lectura en el byte %s leyendo %lu bytes en el fichero %s"

#~ msgid "Cannot open pipe"
#~ msgstr "No se puede abrir la tubería"

#~ msgid "Cannot open archive %s"
#~ msgstr "No se puede abrir el archivo %s"

#~ msgid "Cannot exec %s"
#~ msgstr "No se puede ejecutar %s"

# lo mismo de antes. sv
#~ msgid "Child cannot fork"
#~ msgstr "El proceso hijo no puede bifurcarse"

#~ msgid "Cannot read from compression program"
#~ msgstr "No se puede leer del programa de compresión"

#~ msgid "Cannot write to compression program"
#~ msgstr "No se puede escribir al programa de compresión"

#~ msgid "Cannot write to %s"
#~ msgstr "No se puede escribir en %s"

#~ msgid "WARNING: Cannot truncate %s"
#~ msgstr "ATENCIÓN: No se puede truncar %s"

#~ msgid "While waiting for child"
#~ msgstr "Mientras se esperaba al hijo"

# Estos errores son para el debug del programa. A quien le pueda
# interesar sabe lo que quiere decir em+
# ¡Otras veces se ha puesto bifurcar sin el (fork)! Esto es difícil,
# porque también podría ponerse: "No se puede hacer fork()", ya que
# fork() es un punto de entrada a una primitiva Unix; vaya, una
# función. gag
# FIXME. Hablar con el autor.
# en fileutils-3.16.es.po, el autor cambió el "Cannot fork" por "fork
# system call failed", con lo que podría pasar lo mismo ahora. Si no
# hay cambios, yo preferiría: "¡No se puede crear proceso hijo (fork)!"
# jmg
#~ msgid "Cannot fork!"
#~ msgstr "¡No se puede bifurcar!"

#~ msgid "Cannot exec a shell %s"
#~ msgstr "No se puede ejecutar un shell %s"

#~ msgid "Cannot read %s"
#~ msgstr "No se puede leer %s"

#~ msgid "Error while closing %s"
#~ msgstr "Error al cerrar %s"

#~ msgid "Cannot read link %s"
#~ msgstr "No se puede leer el enlace %s"

#~ msgid "Could not rewind archive file for verify"
#~ msgstr "No se pudo rebobinar el archivo para verificar"

#~ msgid "Cannot add file %s"
#~ msgstr "No se puede añadir el fichero %s"

#~ msgid "Cannot add directory %s"
#~ msgstr "No se puede añadir el directorio %s"

#~ msgid "Cannot open directory %s"
#~ msgstr "No se puede abrir el directorio %s"

#~ msgid "%s: Could not write to file"
#~ msgstr "%s: No se pudo escribir en el fichero"

#~ msgid "%s: Could not create file"
#~ msgstr "%s: No se pudo crear el fichero"

#~ msgid "%s: Error while closing"
#~ msgstr "%s: Error al cerrar"

#~ msgid "%s: Could not make node"
#~ msgstr "%s: No se pudo crear el nodo"

# Pongo comitas porque no es una palabra española.
# A quien no le guste que abra el debate sobre cuándo sí y cuándo no
# deben ponerse comitas en es@li.org.
#~ msgid "%s: Could not make fifo"
#~ msgstr "%s: No se pudo crear el `fifo'"

#~ msgid "%s: Could not create directory"
#~ msgstr "%s: No se pudo crear el directorio"

#~ msgid "Added write and execute permission to directory %s"
#~ msgstr "Añadidos permisos de escritura y ejecución al directorio %s"

#~ msgid "Cannot open file %s"
#~ msgstr "No se puede abrir el fichero %s"

#~ msgid ""
#~ "\n"
#~ "Usage: %s [OPTION]... [FILE]...\n"
#~ msgstr ""
#~ "\n"
#~ "Modo de empleo: %s [OPCIÓN]... [FICHERO]...\n"

# Me encantaría poder incluir tos propuestas de usar el \372 ( aspa ) y
# el (C) , veremos si lo hacemos algún día. em+
# Estaría bien cambiar el '(C)' por '©', que es otro carácter de
# ISO-Latin1. Como los yanquis usan el ASCII (US ISO-646), que es de
# 7 bits, no lo pueden usar; nosotros sí. Incluso "Copyright" por
# "Derechos de copia". Ya lo de FSF por Fundación del Logical Libre
# es demasiado, ¿verdad? :-) gag
# < ¿Puede alguien explicarme por qué no se hace ya, o no se ha hecho
# antes? ¿Qué diferencia hay, bajo el punto de vista de ser caracteres
# válidos, entre 'ó' y 'ß' o entre 'ñ' y '¤' o entre 'º' y '©' o entre
# '¿' y '¼'? Lo único que se me ocurre es que es algo difícil introducir
# esos caracteres porque no están en el teclado del PC. No hay más que
# irse a una terminal o teclado con tecla de Componer o usar el Emacs con
# C-q ooo (ooo = número octal) con la tabla (man iso_8859_1) al lado.
# ¿Alguien tiene otra explicación?
#
# Se ven peor. Estas cosas deben ser bien legibles desde consola, y el
# Copyright ese © no se ve demasiado bien. sv
# Nostoy dacuerdo. Protesto enérgicamente. gerardo
# No tendría ningún inconveniente en usar ese carácter si el objetivo final
# fuera que apareciese por una láser de 300ppp, pero el objetivo es que se
# vea por consola, y con la poca resolución que tiene no es un Copyright
# hecho y derecho sino una C dentro de algo que parece más bien un cuadrado
# con los bordes redondeados. Incluso el (C) Sinclair Research...
# se veía mejor que el de los PCs. sv
# Bueno, eso es un problema del tipo de letra, no del traductor. Además (C)
# es el sucedáneo legal del ©, como TeX cuando no se puede poner como \TeX{}.
# Pero es un sucedáneo, no el original. Es un copyright light. A más a más,
# como dicen los catalanes, que ya aparece delante la palabra Copyright, por
# lo que no debe haber ambigüedad. gerardo
#
# Hombre, el objetivo del traductor es que se entienda, y por ser (C)
# el "sucedáneo legal", como tú le dices, es razonable usarlo.
# En cambio la "ñ" no tiene sucedáneo legal, por lo que poner
# "espagna" o "espa~na" sería completamente inaceptable.
# Y si lo miras bien, todos son sucedáneos, pues las letras no "son"
# pixelizadas. Lo que yo digo es que © no es un sucedáneo más bonito que (C)
# para el símbolo de copyright. sv
#~ msgid ""
#~ "\n"
#~ "Copyright 1988, 92,93,94,95,96,97,98, 1999 Free Software Foundation, "
#~ "Inc.\n"
#~ msgstr ""
#~ "\n"
#~ "Copyright 1988, 92,93,94,95,96,97,98, 1999 Free Software Foundation, "
#~ "Inc.\n"

# Según gag y jmg, hay que decir: "no está en un límite de bloque", pues
# no estamos hablando de un bloque concreto (el bloque) sino de uno cualquiera.
# FIXME: Entonces tal vez el original debería decir "on a block boundary". sv
#~ msgid "Archive %s EOF not on block boundary"
#~ msgstr "El fin del archivo %s no está en un límite de bloque"

# ¿por qué convertir las oraciones unimembres en bimembres? Ya vi
# otro caso en donde se hace y no veo por qué. Bien podría quedar como:
# "Nombre de fichero %s%s demasiado largo". nl
# Algunas de esas frases suenan a "indio" sv
# Hombre, esto no es una novela (del Oeste :-), la forma "india" es
# más literal y más corta, lo que quizá sea más apropiado para mensajes
# concisos como éstos; pero en realidad es más agradable de leer así.
# El traductor manda. gerardo
#~ msgid "File name %s%s too long"
#~ msgstr "El nombre de fichero %s%s es demasiado largo"

#~ msgid "Skipping to next file header"
#~ msgstr "Saltando a la siguiente cabecera de fichero"

#~ msgid "Cannot determine initial working directory"
#~ msgstr "No se puede determinar el directorio de trabajo inicial"

#~ msgid "Could not get current directory"
#~ msgstr "No se pudo obtener el directorio actual"

#~ msgid "Could not get current directory: %s"
#~ msgstr "No se pudo obtener el directorio actual: %s"

#~ msgid "File name %s/%s too long"
#~ msgstr "El nombre del fichero %s/%s es demasiado largo"

#~ msgid "%s: out-of-range timestamp `%s' ignored"
#~ msgstr "%s: no se tendrá en cuenta la marca de fecha `%s' fuera de rango"

#~ msgid "Cannot chdir to %s"
#~ msgstr "No se puede cambiar al directorio %s"

#~ msgid "Arithmetic overflow"
#~ msgstr "Sobrepasamiento aritmético"

# Se vuelca la *memoria* del proceso en un fichero llamado `core'.
#~ msgid " (core dumped)"
#~ msgstr " (memoria volcada)"

#~ msgid "Data differs"
#~ msgstr "Los datos son distintos"

#~ msgid "File does not exist"
#~ msgstr "El fichero no existe"

#~ msgid "Not a regular file"
#~ msgstr "No es un fichero regular"

#~ msgid "Does not exist"
#~ msgstr "No existe"

#~ msgid "No such file or directory"
#~ msgstr "No existe el fichero o el directorio"

#~ msgid "Mode or device-type changed"
#~ msgstr "El modo o el tipo de dispositivo ha cambiado"

#~ msgid "No longer a directory"
#~ msgstr "Ya no es un directorio"

# Lo mismo. sv
# Sugerencia: Sendero -> Ruta, camino. sv
# Lo siento, no me salía la palabra. Esperaba correción. fr
# Siempre he estado usando ruta en otras traducciones em+
# # Esta vez sugiero "camino", por seguir la terminología de
# # Microsoft, ya que da lo mismo, ¿no? gag
# Quedaría igualmente claro si no se hace referencia a ruta:
# "... de los nombres absolutos en el archivo". jmg
#~ msgid "Removing leading `/' from absolute path names in the archive"
#~ msgstr ""
#~ "Borrando la `/' inicial de los nombres absolutos de ruta en el archivo"

#~ msgid "Amount actually written is (I hope) %d.\n"
#~ msgstr "La cantidad realmente escrita (esperemos) es %d.\n"
